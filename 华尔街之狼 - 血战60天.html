<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂçéÂ∞îË°ó‰πãÁãº - Ë°ÄÊàò60Â§©</title>
    <style>
        :root {
            --primary-color: #2962FF;
            --secondary-color: #651FFF; /* AI Button Color */
            --success-color: #00C853;
            --danger-color: #FF3D00;
            --warning-color: #FFAB00;
            --dark-color: #263238;
            --light-color: #ECEFF1;
            --card-bg: #FFFFFF;
            --market-up: #4CAF50;
            --market-down: #F44336;
            --profit-color: #00E676;
            --loss-color: #FF5252;
            --event-color: #7B1FA2; /* For market events */
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 10px;
            margin: 0;
            color: var(--dark-color);
            -webkit-tap-highlight-color: transparent;
            min-height: 100vh;
        }

        #gameContainer {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 1000px;
            box-sizing: border-box;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.3);
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.5rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
            position: relative;
        }

        h1::after {
            content: "";
            display: block;
            width: 40px;
            height: 2px;
            background: var(--primary-color);
            margin: 6px auto 0;
            border-radius: 2px;
        }

        .info-bar {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            background: linear-gradient(to right, var(--primary-color), #3D5AFE);
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-weight: bold;
            font-size: 0.8em;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .info-bar span {
            margin: 5px 10px;
            display: flex;
            align-items: center;
        }

        .info-bar span span {
            margin-left: 5px;
            font-weight: bold;
            color: #FFEB3B;
        }

        #stockTable {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        #stockTable th, #stockTable td {
            padding: 6px 4px;
            text-align: left;
            vertical-align: middle;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            font-size: 0.8em;
        }

        #stockTable th {
            background: linear-gradient(to right, var(--primary-color), #304FFE);
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
            text-align: center;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8em;
            letter-spacing: 0.5px;
        }

        #stockTable tr:not(:first-child) {
            transition: all 0.3s ease;
        }

        #stockTable tr:not(:first-child):hover {
            background-color: rgba(41, 98, 255, 0.05);
            transform: translateX(2px);
        }

        #stockTable tr:nth-child(even) {
            background-color: rgba(0,0,0,0.02);
        }

        .stock-actions input[type="number"] {
            width: 50px;
            padding: 4px;
            margin-right: 4px;
            box-sizing: border-box;
            -moz-appearance: textfield;
            text-align: center;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.8em;
            transition: all 0.2s ease;
        }

        .stock-actions input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(41, 98, 255, 0.2);
        }

        .stock-actions input::-webkit-outer-spin-button,
        .stock-actions input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .stock-actions button {
            padding: 4px 6px;
            cursor: pointer;
            margin-left: 3px;
            border: none;
            border-radius: 3px;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            /* vertical-align: middle; */
            min-width: 24px;
            text-align: center;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .stock-actions button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .stock-actions button:active:not(:disabled) {
            transform: translateY(0);
        }

        /* CN Market Colors */
        .buy-button {
            background: linear-gradient(to right, var(--danger-color), #FF6E40);
        }
        .sell-button {
            background: linear-gradient(to right, var(--success-color), #69F0AE);
        }

        .close-button {
            background: linear-gradient(to right, var(--warning-color), #FFD600);
            color: #333;
        }

        /* Specific style for close button in stock actions to override modal styles */
        td.stock-actions .close-button {
            position: static; /* Override absolute positioning from modal's close-button */
            margin-left: 3px; /* Re-add margin for spacing */
            top: auto; /* Reset top positioning */
            right: auto; /* Reset right positioning */
            font-size: 0.8em; /* Reset font size if necessary */
            min-width: 24px; /* Ensure consistent button size */
        }

        .buy-button:disabled,
        .sell-button:disabled,
        .close-button:disabled {
            background: #B0BEC5;
            cursor: not-allowed;
            color: #ECEFF1;
            box-shadow: none;
        }

        #controls {
            text-align: center;
            margin-bottom: 12px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }

        #nextDayButton, #strategy1Button, #strategy2Button, #strategy3Button, #strategy4Button, #strategy5Button, #strategy6Button, #strategy7Button, #strategy8Button {
            padding: 8px 12px;
            font-size: 0.9em;
            cursor: pointer;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #nextDayButton {
            background: linear-gradient(to right, var(--primary-color), #304FFE);
            box-shadow: 0 4px 8px rgba(41, 98, 255, 0.3);
        }
        #strategy1Button, #strategy2Button, #strategy3Button, #strategy4Button, #strategy5Button, #strategy6Button, #strategy7Button, #strategy8Button {
            background: linear-gradient(to right, var(--secondary-color), #7C4DFF);
            box-shadow: 0 4px 8px rgba(101, 31, 255, 0.3);
        }

        #nextDayButton:hover:not(:disabled),
        #strategy1Button:hover:not(:disabled),
        #strategy2Button:hover:not(:disabled),
        #strategy3Button:hover:not(:disabled),
        #strategy4Button:hover:not(:disabled),
        #strategy5Button:hover:not(:disabled),
        #strategy6Button:hover:not(:disabled),
        #strategy7Button:hover:not(:disabled),
        #strategy8Button:hover:not(:disabled) {
            transform: translateY(-3px);
        }
        #nextDayButton:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(41, 98, 255, 0.4); }
        #strategy1Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy2Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy3Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy4Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy5Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy6Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy7Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy8Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }

        #nextDayButton:active:not(:disabled),
        #strategy1Button:active:not(:disabled),
        #strategy2Button:active:not(:disabled),
        #strategy3Button:active:not(:disabled),
        #strategy4Button:active:not(:disabled),
        #strategy5Button:active:not(:disabled),
        #strategy6Button:active:not(:disabled),
        #strategy7Button:active:not(:disabled),
        #strategy8Button:active:not(:disabled) {
            transform: translateY(0);
        }

        #nextDayButton:disabled,
        #strategy1Button:disabled,
        #strategy2Button:disabled,
        #strategy3Button:disabled,
        #strategy4Button:disabled,
        #strategy5Button:disabled,
        #strategy6Button:disabled,
        #strategy7Button:disabled,
        #strategy8Button:disabled {
            background: #B0BEC5;
            cursor: not-allowed;
            box-shadow: none;
        }

        #log {
            height: 100px;
            overflow-y: scroll;
            border: 1px solid rgba(0,0,0,0.1);
            padding: 12px;
            background-color: #FAFAFA;
            margin-bottom: 20px;
            font-size: 0.85em;
            line-height: 1.4;
            border-radius: 6px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }

        #log p {
            margin: 3px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        #log p:last-child {
            border-bottom: none;
        }

        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            font-size: 1.2em;
            padding: 30px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
        }

        #gameOverScreen h2 {
            margin-top: 0;
            font-size: 2.5em;
            color: #FFEB3B;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        #gameOverScreen p {
            margin: 15px 0;
            font-size: 1.1em;
        }

        #gameOverScreen button {
            padding: 16px 40px;
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 30px;
            background: linear-gradient(to right, var(--success-color), #00E676);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 200, 83, 0.3);
            text-transform: uppercase;
        }

        #gameOverScreen button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 200, 83, 0.4);
        }

        #gameOverScreen button:active {
            transform: translateY(0);
        }

        .table-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 450px;
            -webkit-overflow-scrolling: touch;
            border-radius: 8px;
            margin-bottom: 20px;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .currency {
            text-align: right;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .number {
            text-align: center;
            font-weight: bold;
        }

        .action-cell {
            white-space: nowrap;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stock-name {
            text-align: left;
            font-weight: 500;
        }

        .price-up { color: var(--market-up); font-weight: bold; }
        .price-down { color: var(--market-down); font-weight: bold; }
        .price-unchanged { color: #9E9E9E; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .pulse { animation: pulse 0.5s ease; }
        .fade-in { animation: fadeIn 0.3s ease forwards; }

        /* Loading Screen styles */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: var(--dark-color);
            font-size: 1.5em;
            font-weight: bold;
        }

        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 480px) {
            #gameContainer { padding: 8px; }
            h1 { font-size: 1.2rem; margin-bottom: 8px; }
            .info-bar { font-size: 0.75em; padding: 6px; }
            #stockTable th, #stockTable td { padding: 4px 2px; font-size: 0.75em; }
            .stock-actions input[type="number"] { width: 40px; padding: 3px; font-size: 0.75em; }
            .stock-actions button { padding: 3px 4px; min-width: 20px; font-size: 0.75em; }
            #nextDayButton, #strategy1Button, #strategy2Button, #strategy3Button, #strategy4Button, #strategy5Button, #strategy6Button, #strategy7Button, #strategy8Button { padding: 6px 10px; font-size: 0.8em; }
            #controls { gap: 6px; }
            #gameOverScreen h2 { font-size: 1.5em; }
            #gameOverScreen p { font-size: 0.9em; }
            #gameOverScreen button { padding: 10px 20px; font-size: 0.9em;}
        }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); border-radius: 3px; }
        ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }

        /* New: Help Icon */
        #helpIcon {
            display: inline-block; /* Make it flow with text */
            vertical-align: middle; /* Align with middle of text */
            margin-left: 5px; /* Add some space from the number */
            background-color: var(--primary-color);
            color: white;
            width: 20px; /* Make it a bit smaller to fit inline */
            height: 20px; /* Make it a bit smaller to fit inline */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8em; /* Adjust font size */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* Smaller shadow */
            z-index: 10; /* Lower z-index as it's not absolutely positioned */
            transition: all 0.2s ease;
        }
        #helpIcon:hover {
            background-color: #304FFE;
            transform: scale(1.1); /* Slightly more prominent hover effect */
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 2% auto;
            }
            #helpIcon {
                top: 10px;
                left: 10px;
                width: 18px;
                height: 18px;
                font-size: 0.7em;
            }
        }

        /* New: Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding-top: 60px;
        }

        .modal-content {
            background-color: var(--light-color);
            margin: 5% auto; /* 5% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            border-radius: 12px;
            width: 90%; /* Could be more responsive */
            max-width: 800px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            animation: fadeIn 0.3s ease-out;
            max-height: 85vh; /* Max height to allow scrolling */
            overflow-y: auto; /* Enable scrolling for content */
        }

        .modal-content h2 {
            color: var(--primary-color);
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .modal-content h3 {
            color: var(--secondary-color);
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 2px solid rgba(101, 31, 255, 0.2);
            padding-bottom: 5px;
        }

        .modal-content p {
            margin-bottom: 8px;
            line-height: 1.6;
        }

        .modal-content ul {
            list-style-type: disc;
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .modal-content li {
            margin-bottom: 5px;
        }

        /* Close Button */
        .close-button {
            color: #aaa;
            position: absolute;
            top: 15px;
            right: 25px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--danger-color);
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="loadingScreen">
        <div class="spinner"></div>
        <p>ÂçéÂ∞îË°óÁöÑÊõôÂÖâÊ≠£Âú®ÂçáËµ∑...</p>
    </div>

    <div id="gameContainer" style="display: none;">
        <h1>ÂçéÂ∞îË°ó‰πãÁãº - Ë°ÄÊàò60Â§©</h1>

        <div class="info-bar">
            <span>Â§©Êï∞: <span id="currentDay">0</span>/60 <div id="helpIcon" title="Êü•ÁúãÁ≠ñÁï•ËØ¥Êòé">?</div></span>
            <span>Áé∞Èáë: <span id="cashDisplay">¬•0.00</span></span>
            <span>ÊåÅ‰ªìÂ∏ÇÂÄº: <span id="portfolioValueDisplay">¬•0.00</span></span>
            <span>ÊÄªËµÑ‰∫ß: <span id="netWorthDisplay">¬•0.00</span></span>
        </div>

        <div id="log">
            <!-- Log messages will appear here -->
        </div>

        <div id="controls">
            <button id="nextDayButton">ÂºÄÂßãÊ∏∏Êàè</button>
            <button id="strategy1Button" disabled title="Ê†πÊçÆËÇ°Á•®ÊØèÊó•‰ª∑Ê†ºÁöÑÊòæËëóË∑åÂπÖ‰π∞ÂÖ•ÔºåÂú®ÊòæËëóÊ∂®ÂπÖ„ÄÅËææÂà∞Ê≠¢ÁõàÁÇπÊàñËß¶ÂèäÊ≠¢ÊçüÁ∫øÊó∂ÂçñÂá∫„ÄÇËøΩÊ±ÇÁü≠ÊúüÊ≥¢Âä®Êî∂Áõä„ÄÇ">Á≠ñÁï• 1: Ê∂®Ë∑åÂπÖËøΩÂáªËÄÖ</button>
            <button id="strategy2Button" disabled title="ÂØªÊâæ‰ª∑Ê†º‰Ωé‰∫éÂπ≥ÂùáÊ∞¥Âπ≥ÊàñÁªùÂØπÂÄºËæÉ‰ΩéÁöÑ&quot;‰æøÂÆúËÇ°&quot;ÔºåÈïøÊúüÊåÅÊúâ„ÄÇÂú®‰ª∑Ê†ºÂ§ßÂπÖ‰∏äÊ∂®Âπ∂ËææÂà∞Ê≠¢ÁõàÁÇπÊó∂ÂçñÂá∫„ÄÇÊ≥®ÈáçÈïøÊúü‰ª∑ÂÄºÊäïËµÑ„ÄÇ">Á≠ñÁï• 2: ‰ª∑ÂÄºÊäïËµÑËÄÖ</button>
            <button id="strategy3Button" disabled title="ÁßØÊûÅÂìçÂ∫îÂ∏ÇÂú∫‰∫ã‰ª∂ÔºöËã•ËÇ°Á•®ÂèóÊ≠£Èù¢‰∫ã‰ª∂ÂΩ±ÂìçÂàô‰π∞ÂÖ•ÔºõËã•ÂèóË¥üÈù¢‰∫ã‰ª∂ÂΩ±ÂìçÂàôÂçñÂá∫„ÄÇÂêåÊó∂Ôºå‰πü‰ºöÂØπÂ∑≤ÊåÅÊúâÁöÑÈ´òÂà©Ê∂¶ËÇ°Á•®ËøõË°åÊ≠¢Áõà„ÄÇ">Á≠ñÁï• 3: ‰∫ã‰ª∂ÂìçÂ∫îËÄÖ</button>
            <button id="strategy4Button" disabled title="ËøΩÊ±ÇÈ¢ëÁπÅÁöÑÂ∞èÈ¢ù‰∫§Êòì„ÄÇÂú®ËÇ°Á•®Â∞èÂπÖ‰∏äÊ∂®Êó∂Âø´ÈÄü‰π∞ÂÖ•ÔºåÂπ∂Âú®ËææÂà∞ÂæÆËñÑÂà©Ê∂¶ÊàñÂá∫Áé∞Â∞èÂπÖ‰∏ãË∑åÊó∂ËøÖÈÄüÂçñÂá∫„ÄÇÊ≥®ÈáçÊó•ÂÜÖ‰∫§ÊòìÂíåËµÑÈáëÂë®ËΩ¨„ÄÇ">Á≠ñÁï• 4: Â∞èÊ≠•Âø´Ë∑ëËÄÖ</button>
            <button id="strategy5Button" disabled title="Êó®Âú®ÊûÑÂª∫Âπ∂Áª¥ÊåÅ‰∏Ä‰∏™ÂπøÊ≥õÂàÜÊï£ÁöÑÊäïËµÑÁªÑÂêà„ÄÇÂú®ÊåÅËÇ°Êï∞Èáè‰∏çË∂≥ÊàñÊüê‰∫õËÇ°Á•®ÊùÉÈáçËøá‰ΩéÊó∂‰π∞ÂÖ•ÔºõÂú®ËÇ°Á•®Â∏ÇÂÄºÂç†ÊØîËøáÈ´òÊó∂ÂçñÂá∫‰ª•ËøõË°åÂÜçÂπ≥Ë°°„ÄÇ">Á≠ñÁï• 5: Â§öÂÖÉÂåñÊäïËµÑËÄÖ</button>
            <button id="strategy6Button" disabled title="ËØÜÂà´Âπ∂Ë∑üÈöèËÇ°Á•®ÁöÑÁü≠Êúü‰ª∑Ê†ºË∂ãÂäø„ÄÇÂΩì‰ª∑Ê†ºÊåÅÁª≠‰∏äÊ∂®Êó∂‰π∞ÂÖ•ÔºåÊåÅÁª≠‰∏ãË∑åÊó∂ÂçñÂá∫„ÄÇ">Á≠ñÁï• 6: Ë∂ãÂäøËøΩË∏™ËÄÖ</button>
            <button id="strategy7Button" disabled title="Âà©Áî®ËÇ°Á•®‰ª∑Ê†ºÂõ¥ÁªïÂÖ∂ÂÜÖÂú®‰ª∑ÂÄºÊ≥¢Âä®ÁöÑÁâπÊÄß„ÄÇÂΩì‰ª∑Ê†ºÊòæËëó‰Ωé‰∫éÊàñÈ´ò‰∫éÂÜÖÂú®‰ª∑ÂÄºÊó∂ËøõË°å‰∫§ÊòìÔºåÊúüÂæÖ‰ª∑Ê†ºÂõûÂΩí„ÄÇ">Á≠ñÁï• 7: ‰ª∑ÂÄºÂõûÂΩíËÄÖ</button>
            <button id="strategy8Button" disabled title="ËØÜÂà´Âπ∂Ë∑üÈöèËÇ°Á•®ÁöÑÁü≠Êúü‰ª∑Ê†ºË∂ãÂäø„ÄÇÂΩì‰ª∑Ê†ºÊåÅÁª≠‰∏äÊ∂®Êó∂‰π∞ÂÖ•ÔºåÊåÅÁª≠‰∏ãË∑åÊó∂ÂçñÂá∫„ÄÇÂèÇÊï∞ÔºöÂü∫‰∫é5Êó•SMAÔºå‰ª∑Ê†ºÈ´ò‰∫éSMA 0.5%‰π∞ÂÖ•Ôºå‰Ωé‰∫éSMA 0.5%ÂçñÂá∫ÔºåÊ≠¢Áõà15%ÔºåÊ≠¢Êçü5%„ÄÇ">Á≠ñÁï• 8: Ë∂ãÂäøËøΩË∏™‰ºòÂåñ</button>
            <button id="buyAllStocksButton">Èõ®Èú≤ÂùáÊ≤æ</button>
            <button id="sellAllButton">ÂÖ®‰ªìÂçñÂá∫ÊâÄÊúâ</button>
            <button id="sellHalfButton">Âçä‰ªìÂçñÂá∫ÊâÄÊúâ</button>
            <button id="sellQuarterButton">ÂõõÂàÜ‰πã‰∏Ä‰ªìÂçñÂá∫ÊâÄÊúâ</button>
            <div style="margin-top: 15px; border-top: 1px dashed rgba(0,0,0,0.1); padding-top: 15px; width: 100%;">
                <h3 style="color: var(--secondary-color); font-size: 1em; margin-bottom: 10px; text-align: center;">Ëá™Ë°åÊ∑ªÂä†ËÇ°Á•®</h3>
                <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 8px;">
                    <input type="text" id="newStockName" placeholder="ËÇ°Á•®ÂêçÁß∞" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 120px;">
                    <input type="text" id="newStockCode" placeholder="ËÇ°Á•®‰ª£Á†Å" maxlength="6" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 80px;">
                    <input type="number" id="newStockPrice" placeholder="ÂàùÂßã‰ª∑Ê†º" min="0.01" step="0.01" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100px;">
                    <button id="addStockButton" style="background: linear-gradient(to right, #4CAF50, #8BC34A); color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;">Ê∑ªÂä†ËÇ°Á•®</button>
                    <button id="clearSavedStocksButton" style="background: linear-gradient(to right, #FF9800, #FFB74D); color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;">Ê∏ÖÁ©∫ËÇ°Á•®</button>
                </div>
            </div>
        </div>

        <div class="table-container">
            <table id="stockTable">
                <thead>
                    <tr>
                        <th>ÂêçÁß∞</th>
                        <th>‰ª£Á†Å</th>
                        <th>‰ª∑Ê†º</th>
                        <th>Ê∂®Ë∑åÂπÖ</th>
                        <th>ÊåÅ‰ªì</th>
                        <th>Â∏ÇÂÄº</th>
                        <th>Êìç‰Ωú</th>
                    </tr>
                </thead>
                <tbody id="stockTableBody">
                    <!-- Stock rows generated by JS -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- New: Strategy Help Modal -->
    <div id="strategyHelpModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Ëá™Âä®‰∫§ÊòìÁ≠ñÁï•ËØ¥Êòé</h2>
            <div id="strategyExplanationContent">
                <!-- Strategy explanations will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <div id="gameOverScreen">
        <h2>ÊäïËµÑËØ¶ÊÉÖ</h2>
        <p>ÊÇ®Â∑≤ÁªèÂÆåÊàê‰∫Ü60Â§©ÁöÑ‰∫§ÊòìÊåëÊàò</p>
        <p>ÂàùÂßãËµÑÈáë: ¬•<span id="initialCapitalResult"></span></p>
        <p>ÊúÄÁªàËµÑ‰∫ß: ¬•<span id="finalNetWorthResult"></span></p>
        <p>Áõà‰∫è: <span id="profitLossResult"></span></p>
        <p>Áõà‰∫èÊØî‰æã: <span id="profitLossPercentageResult"></span> <!-- New: Profit/Loss Percentage -->
        <p>ÊÇ®ÁöÑÁß∞Âè∑: <span id="playerTitle"></span></p>
        <p>ÈááÁî®Á≠ñÁï•: <span id="usedStrategyDisplay"></span> <!-- New: Used Strategy Display -->
        <p>Â∑ÖÂ≥∞ËµÑ‰∫ß: ¬•<span id="peakNetWorthDisplay"></span></p> <!-- New: Peak Net Worth Display -->
        <p>ÊúÄ‰ΩéËµÑ‰∫ß: ¬•<span id="troughNetWorthDisplay"></span></p> <!-- New: Trough Net Worth Display -->
        <div id="aiTradeHistoryDisplay" style="margin-top: 20px; text-align: left; max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px;"></div>
        <p>ÊÄª‰∫§ÊòìÊ¨°Êï∞: <span style="color:#FFEB3B;" id="finalTotalTrades"></span></p>
        <p>ÊÄª‰∫§ÊòìÁ®éË¥π: <span style="color:#FFEB3B;" id="finalTotalFees"></span></p>
        <button id="playAgainButton">ÂÜçÊàò‰∏ÄËΩÆ</button>
    </div>

    <script>
        // --- Game Configuration ---
        const INITIAL_CASH = 5000000;
        const NUM_STOCKS = 0; // Changed from 10 to 0
        const MAX_DAYS = 60; // Changed from 180 to 60
        const MIN_PRICE = 0.01;
        const MAX_PRICE_FLUCTUATION_PERCENT = 8;
        const INITIAL_PRICE_MIN = 10;
        const INITIAL_PRICE_MAX = 150;
        const DEFAULT_TRADE_QUANTITY = 100;
        const SWIPE_INCREMENT_QUANTITY = 100;
        const SWIPE_THRESHOLD_PX = 30;

        // New: Transaction Fee
        const TRANSACTION_FEE_PERCENT = 0.015; // ‰∏áÂàÜ‰πã‰∏â = 0.015%

        // New: Market Simulation Parameters
        const MOMENTUM_FACTOR = 0.3; // How much previous day's change influences current day's change (0 to 1)
        const BASE_PRICE_GROWTH_RATE_MIN = -0.05; // Annual growth rate min for base price (-5%)
        const BASE_PRICE_GROWTH_RATE_MAX = 0.10; // Annual growth rate max for base price (10%)

        // AI Configuration (Strategic AI)
        const AI_BUY_MIN = 3; // Min stocks AI tries to buy per click
        const AI_BUY_MAX = 8; // Max stocks AI tries to buy per click

        // Market Event Configuration
        const POSITIVE_EVENT_EFFECT_MIN = 15; // +15%
        const POSITIVE_EVENT_EFFECT_MAX = 40; // +40%
        const NEGATIVE_EVENT_EFFECT_MIN = 15; // -15%
        const NEGATIVE_EVENT_EFFECT_MAX = 40; // -40%

        // Strategy 6: Ë∂ãÂäøËøΩË∏™ËÄÖ (Trend Follower)
        const TREND_FOLLOW_SMA_PERIOD = 5; // SMA Period for trend detection
        const TREND_FOLLOW_BUY_ABOVE_SMA_PERCENT = 0.5; // Buy if price is 0.5% above SMA
        const TREND_FOLLOW_SELL_BELOW_SMA_PERCENT = 0.5; // Sell if price is 0.5% below SMA
        const TREND_FOLLOW_PROFIT_TAKE_PERCENT = 10; // Profit target
        const TREND_FOLLOW_STOP_LOSS_PERCENT = 5; // Stop loss
        const TREND_FOLLOW_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 2; // Trade quantity

        // Strategy 7: ‰ª∑ÂÄºÂõûÂΩíËÄÖ (Mean Reversion)
        const MEAN_REVERSION_SMA_PERIOD = 10; // Longer SMA Period for intrinsic value
        const MEAN_REVERSION_BUY_BELOW_SMA_PERCENT = 5; // Buy if price is 5% below SMA
        const MEAN_REVERSION_SELL_ABOVE_SMA_PERCENT = 5; // Sell if price is 5% above SMA
        const MEAN_REVERSION_PROFIT_TAKE_PERCENT = 25; // Profit target
        const MEAN_REVERSION_STOP_LOSS_PERCENT = 5; // Stop loss
        const MEAN_REVERSION_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY; // Trade quantity

        // Strategy 8: Ë∂ãÂäøËøΩË∏™‰ºòÂåñ (Trend Tracking Optimization)
        const TREND_TRACKING_OPTIMIZED_SMA_PERIOD = 5; // SMA Period for trend detection
        const TREND_TRACKING_OPTIMIZED_BUY_ABOVE_SMA_PERCENT = 0.5; // Buy if price is 0.5% above SMA
        const TREND_TRACKING_OPTIMIZED_SELL_BELOW_SMA_PERCENT = 0.5; // Sell if price is 0.5% below SMA
        const TREND_TRACKING_OPTIMIZED_PROFIT_TAKE_PERCENT = 15; // Profit target
        const TREND_TRACKING_OPTIMIZED_STOP_LOSS_PERCENT = 5; // Stop loss
        const TREND_TRACKING_OPTIMIZED_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 2; // Trade quantity

        // New: Per-stock event probability
        const PER_STOCK_EVENT_PROBABILITY = 0.03; // Each stock has a 3% chance of an event each day

        const marketEvents = [
            // Positive Events
            { type: 'positive', name: 'Á™ÅÁ†¥ÊÄßÊäÄÊúØÂÖ¨Â∏É', description: 'Êñ∞ÊùêÊñôÁßëÊäÄÂèñÂæóÈáçÂ§ßËøõÂ±ï!', effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN, icon: 'üöÄ' },
            { type: 'positive', name: 'Ë¥¢Êä•Ë∂ÖÈ¢ÑÊúü', description: 'ÂÖ¨Âè∏ÁõàÂà©ËøúË∂ÖÂ∏ÇÂú∫È¢ÑÊúü!', effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN, icon: 'üí∞' },
            { type: 'positive', name: 'ÈáçÂ§ßÂà©Â•ΩÊîøÁ≠ñ', description: 'ÊîøÂ∫úÈ¢ÅÂ∏ÉË°å‰∏öÊâ∂ÊåÅÊîøÁ≠ñÔºåÂ∏ÇÂú∫‰ø°ÂøÉÂ§ßÂ¢û!', effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN, icon: 'üåü' },
            { type: 'positive', name: 'Êî∂Ë¥≠ÂÖºÂπ∂ÊàêÂäü', description: 'Âº∫Âº∫ËÅîÂêàÔºåÂ∏¶Êù•ÂçèÂêåÊïàÂ∫î!', effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN, icon: 'ü§ù' },
            // Negative Events
            { type: 'negative', name: 'Á™ÅÂèëË¥üÈù¢Êñ∞Èóª', description: 'ÂÖ¨Âè∏‰∫ßÂìÅË¢´ÊõùÂÆâÂÖ®ÈöêÊÇ£!', effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN), icon: 'üö®' },
            { type: 'negative', name: 'Ê†∏ÂøÉÈ´òÁÆ°Á¶ªËÅå', description: 'ÂÖ¨Âè∏È¶ñÂ∏≠ÊâßË°åÂÆòÁ™ÅÁÑ∂ËæûËÅå!', effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN), icon: 'üëî' },
            { type: 'negative', name: 'Ë°å‰∏öÊîøÁ≠ñÊî∂Á¥ß', description: 'ÁõëÁÆ°ÈÉ®Èó®Âä†Âº∫ÁÆ°ÊéßÔºåÂ∏ÇÂú∫ÂâçÊôØ‰∏çÊòé!', effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN), icon: 'üö®' },
            { type: 'negative', name: '‰∫ßÂìÅÂè¨Âõû‰∫ã‰ª∂', description: 'Â§ßËßÑÊ®°‰∫ßÂìÅÂè¨ÂõûÔºåÊ∂àË¥πËÄÖ‰ø°ÂøÉÂèóÊå´!', effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN), icon: '‚ö°' },
        ];

        // Dynamically add more positive events
        const additionalPositiveEvents = [
            { name: 'Êñ∞ËçØÁ†îÂèëÊàêÂäü', description: 'Á™ÅÁ†¥ÊÄßËçØÁâ©Ëé∑Êâπ‰∏äÂ∏ÇÔºÅ' },
            { name: 'ÂÖ®ÁêÉËÆ¢ÂçïÊøÄÂ¢û', description: 'ÂõΩÈôÖÂ∏ÇÂú∫ÈúÄÊ±ÇÊó∫ÁõõÔºåÂá∫Âè£È¢ùÂàõÊñ∞È´òÔºÅ' },
            { name: 'ÊàòÁï•Âêà‰ΩúËææÊàê', description: '‰∏éË°å‰∏öÂ∑®Â§¥Á≠æÁΩ≤ÈïøÊúüÂêà‰ΩúÂçèËÆÆÔºÅ' },
            { name: 'ÊîøÂ∫úË°•Ë¥¥Âä†Á†Å', description: 'Ëé∑ÂæóÂ∑®È¢ùË¥¢ÊîøÊîØÊåÅÔºåÂèëÂ±ïÂâçÊôØÂπøÈòîÔºÅ' },
            { name: 'ÊäÄÊúØ‰∏ìÂà©Ëé∑Êâπ', description: 'Ê†∏ÂøÉÊäÄÊúØÂæóÂà∞Ê≥ïÂæã‰øùÊä§ÔºåÁ´û‰∫â‰ºòÂäøÂá∏ÊòæÔºÅ' },
            { name: 'Ê∂àË¥πËÄÖ‰ø°ÂøÉÊåáÊï∞Â§ßÊ∂®', description: 'Â∏ÇÂú∫ÊÉÖÁª™È´òÊ∂®ÔºåÊ∂àË¥πÊÑèÊÑøÂº∫ÁÉàÔºÅ' },
            { name: 'ÂõΩÈôÖËØÑÁ∫ß‰∏äË∞É', description: '‰ø°Áî®Á≠âÁ∫ßÊèêÂçáÔºåËûçËµÑÊàêÊú¨Èôç‰ΩéÔºÅ' },
            { name: 'ÁªøËâ≤ËÉΩÊ∫êÊñ∞Êîø', description: 'Êñ∞ËÉΩÊ∫ê‰∫ß‰∏öËøéÊù•ÊîøÁ≠ñÂà©Â•ΩÔºåÂèëÂ±ïÊèêÈÄüÔºÅ' },
            { name: 'ÊóÖÊ∏∏‰∏öÂ§çËãè', description: 'ËæπÂ¢ÉÂºÄÊîæÔºåÊóÖÊ∏∏Ê∂àË¥π‰∫ïÂñ∑ÂºèÂ¢ûÈïøÔºÅ' },
            { name: 'Â§ßÂÆóÂïÜÂìÅ‰ª∑Ê†º‰∏äÊ∂®', description: 'ÂéüÊùêÊñô‰ª∑Ê†ºÊîÄÂçáÔºåÁõ∏ÂÖ≥‰∫ß‰∏öÂà©Ê∂¶‰∏∞ÂéöÔºÅ' },
            { name: 'Êñ∞ÂÖ¥Â∏ÇÂú∫Êú∫ÈÅá', description: 'Âú®Êñ∞ÂÖ¥ÁªèÊµé‰ΩìÂèñÂæóÈáçÂ§ß‰∏öÂä°Á™ÅÁ†¥ÔºÅ' },
            { name: 'Á†îÂèëÊäïÂÖ•ÂõûÊä•‰∏∞Âéö', description: 'È´òÊäïÂÖ•Á†îÂèëÈ°πÁõÆÁªìÂá∫Á°ïÊûúÔºÅ' },
            { name: 'ÂìÅÁâåÂΩ±ÂìçÂäõÊèêÂçá', description: 'ÂÖ¨Âè∏ÂìÅÁâåÁü•ÂêçÂ∫¶Â§ßÂπÖÊèêÂçáÔºåÂ∏ÇÂú∫Âç†ÊúâÁéáÊâ©Â§ßÔºÅ' },
            { name: 'Êµ∑Â§ñÂ∏ÇÂú∫Êâ©Âº†', description: 'ÊàêÂäüÊâìÂÖ•ÂõΩÈôÖÂ∏ÇÂú∫Ôºå‰∏öÂä°ÁâàÂõæÊåÅÁª≠Êâ©Â§ßÔºÅ' },
            { name: 'ÁÆ°ÁêÜÂ±ÇÂèòÂä®Âà©Â•Ω', description: 'Êñ∞ÁÆ°ÁêÜÂ±Ç‰∏ä‰ªªÔºåÂ∏ÇÂú∫È¢ÑÊúüÂêëÂ•ΩÔºÅ' },
            { name: '‰æõÂ∫îÈìæ‰ºòÂåñ', description: '‰æõÂ∫îÈìæÊïàÁéáÂ§ßÂπÖÊèêÂçáÔºåÊàêÊú¨ÊòæËëó‰∏ãÈôçÔºÅ' },
            { name: 'Êï∞Â≠óÂåñËΩ¨ÂûãÊàêÂäü', description: 'Êï∞Â≠óÂåñÊàòÁï•ÂàùÊòæÊàêÊïàÔºåËøêËê•ÊïàÁéáÊèêÈ´òÔºÅ' },
            { name: 'ÁéØ‰øùÊäÄÊúØÁ™ÅÁ†¥', description: 'Á†îÂèëÂá∫ÂàõÊñ∞ÁéØ‰øùÊäÄÊúØÔºåÂ∏ÇÂú∫ÂâçÊôØÂπøÈòîÔºÅ' },
            { name: 'Ë°å‰∏öÂçè‰ºöÂäõÊå∫', description: 'Ëé∑ÂæóË°å‰∏öÂçè‰ºöÂ§ßÂäõÊîØÊåÅÔºåÂ∏ÇÂú∫Âú∞‰ΩçÁ®≥Âõ∫ÔºÅ' },
            { name: 'Ê∂àË¥πÂçáÁ∫ßË∂ãÂäø', description: 'Êäì‰ΩèÊ∂àË¥πÂçáÁ∫ßÊú∫ÈÅáÔºåÈ´òÁ´Ø‰∫ßÂìÅÈîÄÈáèÂ§ßÂ¢ûÔºÅ' },
            { name: 'ÊàêÂäüÂèëË°åÊñ∞ÂÄ∫', description: '‰ΩéÊàêÊú¨ËûçËµÑÔºåËµÑÈáëÈìæÂÖÖË∂≥ÔºÅ' },
            { name: 'ËÇ°Á•®ÂõûË¥≠ËÆ°Âàí', description: 'ÂÖ¨Âè∏ÂÆ£Â∏ÉÂ§ßËßÑÊ®°ËÇ°Á•®ÂõûË¥≠ÔºåÊèêÊåØËÇ°‰ª∑ÔºÅ' },
            { name: 'ÂàÜÁ∫¢ÊñπÊ°àË∂ÖÈ¢ÑÊúü', description: 'È´òÈ¢ùÂàÜÁ∫¢ÊñπÊ°àÂá∫ÁÇâÔºåÂê∏ÂºïÊäïËµÑËÄÖÔºÅ' },
            { name: 'ÊàòÁï•ÊäïËµÑËÄÖÂÖ•ËÇ°', description: 'Áü•ÂêçÊäïËµÑÊú∫ÊûÑÊàòÁï•ÂÖ•ËÇ°ÔºåÂâçÊôØÁúãÂ•ΩÔºÅ' },
            { name: '‰∫ßÂìÅËé∑ÂæóÂõΩÈôÖÂ§ßÂ•ñ', description: '‰∫ßÂìÅË¥®ÈáèÂíåÂàõÊñ∞Ëé∑ÂæóÂõΩÈôÖËÆ§ÂèØÔºÅ' },
            { name: '‰∫ßËÉΩÊâ©Âº†ÊàêÂäü', description: 'Êñ∞Â¢û‰∫ßËÉΩÈ°∫Âà©Êäï‰∫ßÔºåËê•Êî∂Â¢ûÈïøÂèØÊúüÔºÅ' },
            { name: 'Â∞±‰∏öÊï∞ÊçÆÂº∫Âä≤', description: 'ÂÖ®ÂõΩÂ∞±‰∏öÁéáÊåÅÁª≠Â¢ûÈïøÔºåÁªèÊµéÊ¥ªÂäõÂ¢ûÂº∫ÔºÅ' },
            { name: 'Âá∫Âè£Êï∞ÊçÆË∂ÖÈ¢ÑÊúü', description: 'Âá∫Âè£Ë¥∏ÊòìÈ¢ùÂ§ßÂπÖÂ¢ûÈïøÔºåÂõΩÈôÖÁ´û‰∫âÂäõÊèêÂçáÔºÅ' },
            { name: 'ÂàõÊñ∞‰∫ßÂìÅÂèëÂ∏É', description: 'ÂèëÂ∏ÉÂàíÊó∂‰ª£Êñ∞‰∫ßÂìÅÔºåÂºïÂèëÂ∏ÇÂú∫ËΩ∞Âä®ÔºÅ' },
            { name: 'Á®éÊî∂‰ºòÊÉ†ÊîøÁ≠ñ', description: 'ÊîøÂ∫úÂá∫Âè∞Á®éÊî∂ÂáèÂÖçÊîøÁ≠ñÔºåÈôç‰Ωé‰ºÅ‰∏öË¥üÊãÖÔºÅ' },
            { name: 'Âü∫Á°ÄËÆæÊñΩÂª∫ËÆæÂä†ÈÄü', description: 'ÂõΩÂÆ∂Â§ßÂäõÊäïËµÑÂü∫Âª∫ÔºåÁõ∏ÂÖ≥‰∫ß‰∏öÂèóÁõäÔºÅ' },
            { name: 'ÂéüÊùêÊñô‰ª∑Ê†ºÂõûËêΩ', description: 'ÊàêÊú¨ÂéãÂäõÁºìËß£Ôºå‰ºÅ‰∏öÂà©Ê∂¶Á©∫Èó¥Êâ©Â§ßÔºÅ' },
            { name: '‰∫∫Âè£Á∫¢Âà©ÊòæÁé∞', description: 'Âä≥Âä®ÂäõÂ∏ÇÂú∫‰æõÈúÄÊîπÂñÑÔºåÁîü‰∫ßÊïàÁéáÊèêÈ´òÔºÅ' },
            { name: 'ÂüéÂ∏ÇÂåñËøõÁ®ãÂä†Âø´', description: 'ÂüéÂ∏Ç‰∫∫Âè£Â¢ûÈïøÔºåÂ∏¶Âä®ÊàøÂú∞‰∫ßÂèäÁõ∏ÂÖ≥‰∫ß‰∏öÔºÅ' },
            { name: 'ÂåªÁñóÊîπÈù©Âà©Â•Ω', description: 'ÂåªÁñóÂÅ•Â∫∑È¢ÜÂüüËøéÊù•ÊîøÁ≠ñÊò•Â§©ÔºåÂ∏ÇÂú∫ÊΩúÂäõÂ∑®Â§ßÔºÅ' },
            { name: 'ÊïôËÇ≤ÊäïÂÖ•Â¢ûÂä†', description: 'ÊîøÂ∫úÂä†Â§ßÊïôËÇ≤ÊîØÂá∫ÔºåÊïôËÇ≤Ë°å‰∏öÂèëÂ±ïËøÖÁåõÔºÅ' },
            { name: 'ÂÜú‰∏öÁßëÊäÄÁ™ÅÁ†¥', description: 'ÂÜú‰∏öÁîü‰∫ßÊïàÁéáÊèêÂçáÔºåÈ£üÂìÅÂÆâÂÖ®ÂæóÂà∞‰øùÈöúÔºÅ' },
            { name: 'ÊñáÂåñ‰∫ß‰∏öÁπÅËç£', description: 'ÊñáÂåñÂ®±‰πêÊ∂àË¥πÈúÄÊ±ÇÊó∫ÁõõÔºåË°å‰∏öÂèëÂ±ïÂäøÂ§¥ËâØÂ•ΩÔºÅ' },
            { name: '‰ΩìËÇ≤‰∫ß‰∏öÂèëÂ±ï', description: '‰ΩìËÇ≤Ëµõ‰∫ãÂíåÂÅ•Ë∫´Ê¥ªÂä®ÂÖ¥Ëµ∑ÔºåÁõ∏ÂÖ≥‰∫ß‰∏öËì¨ÂãÉÂèëÂ±ïÔºÅ' },
            { name: 'ÂõΩÈò≤ÂÜõÂ∑•ËÆ¢Âçï', description: 'Ëé∑ÂæóÂ§ßÈáèÂõΩÈò≤ÂÜõÂ∑•ËÆ¢ÂçïÔºå‰∏öÁª©Á®≥ÂÆöÂ¢ûÈïøÔºÅ' },
            { name: 'Âå∫ÂùóÈìæÊäÄÊúØÂ∫îÁî®', description: 'Âå∫ÂùóÈìæÊäÄÊúØÂú®ÈáëËûçÈ¢ÜÂüüÂèñÂæóÁ™ÅÁ†¥ÊÄßÂ∫îÁî®ÔºÅ' },
            { name: '‰∫∫Â∑•Êô∫ËÉΩÊôÆÂèä', description: 'AIÊäÄÊúØÊ∏óÈÄèÂêÑË°åÂêÑ‰∏öÔºåÊèêÈ´òÁîü‰∫ßÂäõÔºÅ' },
            { name: 'Â§ßÊï∞ÊçÆÂàÜÊûêËøõÂ±ï', description: 'Â§ßÊï∞ÊçÆÂ∫îÁî®Â∏ÆÂä©‰ºÅ‰∏öÁ≤æÂáÜÂÜ≥Á≠ñÔºÅ' },
            { name: '‰∫ëËÆ°ÁÆóÊúçÂä°Â¢ûÈïø', description: '‰∫ëÊúçÂä°ÈúÄÊ±ÇÁàÜÂèëÔºåÁõ∏ÂÖ≥ÂÖ¨Âè∏Ëê•Êî∂Â§ßÂ¢ûÔºÅ' },
            { name: 'Áâ©ËÅîÁΩëËÆæÂ§áÊôÆÂèä', description: 'Êô∫ËÉΩËÆæÂ§áËøûÊé•Êï∞ÈáèÊøÄÂ¢ûÔºå‰∏áÁâ©‰∫íËÅîÊó∂‰ª£Âä†ÈÄüÔºÅ' },
            { name: '5GÁΩëÁªúË¶ÜÁõñ', description: '5GÂü∫Á´ôÂª∫ËÆæÂä†ÈÄüÔºåÈÄö‰ø°Ë°å‰∏öËøéÊù•ÂèëÂ±ïÈ´òÂ≥∞ÔºÅ' },
            { name: 'Ëá™Âä®È©æÈ©∂ÊäÄÊúØÊàêÁÜü', description: 'Ëá™Âä®È©æÈ©∂ÂïÜ‰∏öÂåñËêΩÂú∞ÔºåÊ±ΩËΩ¶Ë°å‰∏öËøéÊù•ÂèòÈù©ÔºÅ' },
            { name: 'Â§™Á©∫Êé¢Á¥¢Êñ∞ËøõÂ±ï', description: 'ÂïÜ‰∏öËà™Â§©ÂÖ¨Âè∏ÂèñÂæóÈáçÂ§ßÁ™ÅÁ†¥ÔºåÂºïÁàÜÂ∏ÇÂú∫ÔºÅ' },
            { name: 'Âü∫Âõ†ÁºñËæëÊäÄÊúØÂàõÊñ∞', description: 'Âü∫Âõ†ÁñóÊ≥ïÂèñÂæóÈáçÂ§ßËøõÂ±ïÔºåÊ≤ªÊÑàÁñëÈöæÊùÇÁóáÔºÅ' },
            { name: 'Êñ∞ÂûãÁîµÊ±†Á†îÂèëÊàêÂäü', description: 'ËÉΩÈáèÂØÜÂ∫¶Â§ßÂ¢ûÔºåÁîµÂä®Ê±ΩËΩ¶Áª≠Ëà™ÈáåÁ®ãÁøªÂÄçÔºÅ' }
        ];

        // Dynamically add more negative events
        const additionalNegativeEvents = [
            { name: 'Á™ÅÂèëÁñ´ÊÉÖÁàÜÂèë', description: 'Êñ∞ÂûãÁóÖÊØíËîìÂª∂ÔºåÁªèÊµéÊ¥ªÂä®ÂÅúÊªûÔºÅ' },
            { name: 'ÂõΩÈôÖË¥∏ÊòìÊë©Êì¶Âä†Ââß', description: 'ÂÖ≥Á®éÂ£ÅÂûíÂçáÈ´òÔºåÂÖ®ÁêÉ‰æõÂ∫îÈìæÂèóÈòªÔºÅ' },
            { name: 'Ëá™ÁÑ∂ÁÅæÂÆ≥‰æµË¢≠', description: '‰∏•ÈáçÊ¥™Ê∂ùÁÅæÂÆ≥ÔºåÂÜú‰∫ßÂìÅ‰æõÂ∫îÁ¥ßÂº†ÔºÅ' },
            { name: 'ÂéüÊùêÊñô‰ª∑Ê†ºÊö¥Ê∂®', description: 'ÂÖ≥ÈîÆÂéüÊùêÊñô‰æõÂ∫îÁü≠Áº∫ÔºåÁîü‰∫ßÊàêÊú¨È£ôÂçáÔºÅ' },
            { name: 'ÁõëÁÆ°ÂÆ°Êü•Êî∂Á¥ß', description: 'ÂèçÂûÑÊñ≠Ë∞ÉÊü•ÂêØÂä®ÔºåÁßëÊäÄÂ∑®Â§¥Èù¢‰∏¥ÊåëÊàòÔºÅ' },
            { name: 'ÂÄ∫Âä°Âç±Êú∫ËîìÂª∂', description: 'Â§öÂõΩÊîøÂ∫úÂÄ∫Âä°È´ò‰ºÅÔºåÂºïÂèëÂ∏ÇÂú∫ÊãÖÂøßÔºÅ' },
            { name: 'Èì∂Ë°å‰ΩìÁ≥ªÈ£éÈô©', description: 'ÈÉ®ÂàÜÈì∂Ë°åÂá∫Áé∞ÊµÅÂä®ÊÄßÈóÆÈ¢òÔºåÈáëËûçÂ∏ÇÂú∫Âä®Ëç°ÔºÅ' },
            { name: 'Âä≥ËµÑÁ∫†Á∫∑ÂçáÁ∫ß', description: 'Â§ßËßÑÊ®°Â∑•‰∫∫ÁΩ¢Â∑•ÔºåÁîü‰∫ßÂèóÂà∞‰∏•ÈáçÂΩ±ÂìçÔºÅ' },
            { name: 'Á´û‰∫âÂØπÊâãÂèçË∂Ö', description: 'Ê†∏ÂøÉ‰∫ßÂìÅË¢´Á´û‰∫âÂØπÊâãË∂ÖË∂äÔºåÂ∏ÇÂú∫‰ªΩÈ¢ùÊµÅÂ§±ÔºÅ' },
            { name: 'È´òÁÆ°Ë¥™ËÖê‰∏ëÈóª', description: 'ÂÖ¨Âè∏È´òÂ±ÇÊõùÂá∫Ë¥™ËÖê‰∏ëÈóªÔºå‰ø°Ë™âÂèóÊçüÔºÅ' },
            { name: '‰∫ßÂìÅË¥®ÈáèÈóÆÈ¢ò', description: 'Â§ßËßÑÊ®°‰∫ßÂìÅÂè¨ÂõûÔºåÊ∂àË¥πËÄÖÊäïËØâÊøÄÂ¢ûÔºÅ' },
            { name: 'ÁΩëÁªúÂÆâÂÖ®ÊºèÊ¥û', description: 'ÂÖ¨Âè∏Á≥ªÁªüÈÅ≠ÂèóÈªëÂÆ¢ÊîªÂáªÔºåÊï∞ÊçÆÊ≥ÑÈú≤ÔºÅ' },
            { name: 'ËØâËÆºÁº†Ë∫´', description: 'Èù¢‰∏¥Â∑®È¢ùËØâËÆºËµîÂÅøÔºåË¥¢Âä°ÂéãÂäõÂ∑®Â§ßÔºÅ' },
            { name: 'ÂÆèËßÇÁªèÊµé‰∏ãË°å', description: 'ÁªèÊµéÂ¢ûÈïøÊîæÁºìÔºåÈÄöË¥ßËÜ®ËÉÄÂéãÂäõÂä†Â§ßÔºÅ' },
            { name: 'ÊàøÂú∞‰∫ßÂ∏ÇÂú∫ÈÅáÂÜ∑', description: 'Ê•ºÂ∏ÇÊàê‰∫§ÈáèÂ§ßÂπÖ‰∏ãÊªëÔºåÁõ∏ÂÖ≥‰∫ß‰∏öÂèóÂÜ≤ÂáªÔºÅ' },
            { name: 'ËÉΩÊ∫ê‰ª∑Ê†ºÊ≥¢Âä®', description: 'ÂõΩÈôÖÊ≤π‰ª∑ÂâßÁÉàÊ≥¢Âä®ÔºåËÉΩÊ∫ê‰ºÅ‰∏öÈù¢‰∏¥ÊåëÊàòÔºÅ' },
            { name: 'Âú∞ÁºòÊîøÊ≤ªÁ¥ßÂº†', description: 'Âú∞Âå∫ÂÜ≤Á™ÅÂçáÁ∫ßÔºåÂÖ®ÁêÉÈÅøÈô©ÊÉÖÁª™ÂçáÊ∏©ÔºÅ' },
            { name: 'ÊäÄÊúØÁì∂È¢àÂá∫Áé∞', description: 'Ê†∏ÂøÉÊäÄÊúØÁ†îÂèëÈÅ≠ÈÅáÁì∂È¢àÔºå‰∫ßÂìÅÂçáÁ∫ßÂèóÈòªÔºÅ' },
            { name: '‰∫∫ÊâçÊµÅÂ§±‰∏•Èáç', description: 'ÂÖ≥ÈîÆÊäÄÊúØ‰∫∫ÊâçÂ§ßÈáèÊµÅÂ§±ÔºåÂΩ±ÂìçÂàõÊñ∞ËÉΩÂäõÔºÅ' },
            { name: 'Â∏ÇÂú∫ÈúÄÊ±ÇËêéÁº©', description: 'Ê∂àË¥πËÄÖË¥≠‰π∞Âäõ‰∏ãÈôçÔºå‰∫ßÂìÅÈîÄÈáèÈîêÂáèÔºÅ' },
            { name: '‰æõÂ∫îÈìæ‰∏≠Êñ≠', description: 'ÂõΩÈôÖÁâ©ÊµÅÂèóÈòªÔºåÂéüÊùêÊñôÂíå‰∫ßÂìÅËøêËæìÂõ∞ÈöæÔºÅ' },
            { name: 'Á´û‰∫âÂä†Ââß', description: 'Â∏ÇÂú∫Á´û‰∫âÁôΩÁÉ≠ÂåñÔºåÂà©Ê∂¶Á©∫Èó¥Ë¢´ÂéãÁº©ÔºÅ' },
            { name: 'Êñ∞ÂÖ¥ÊäÄÊúØÂÜ≤Âáª', description: 'È¢†Ë¶ÜÊÄßÊäÄÊúØÂá∫Áé∞Ôºå‰º†Áªü‰∫ß‰∏öÈù¢‰∏¥Ê∑òÊ±∞ÔºÅ' },
            { name: 'ÁéØÂ¢ÉÊ≥ïËßÑÊî∂Á¥ß', description: 'ÁéØ‰øùÊ†áÂáÜÊèêÈ´òÔºå‰ºÅ‰∏öÂêàËßÑÊàêÊú¨Â¢ûÂä†ÔºÅ' },
            { name: 'Ê∂àË¥πËÄÖÊäµÂà∂', description: 'Âõ†Ë¥üÈù¢‰∫ã‰ª∂ÂºïÂèëÊ∂àË¥πËÄÖÊäµÂà∂ÔºåÂìÅÁâåÂΩ¢Ë±°ÂèóÊçüÔºÅ' },
            { name: 'ËØÑÁ∫ßÊú∫ÊûÑ‰∏ãË∞ÉËØÑÁ∫ß', description: '‰ø°Áî®ËØÑÁ∫ßË¢´‰∏ãË∞ÉÔºåËûçËµÑÈöæÂ∫¶Â¢ûÂä†ÔºÅ' },
            { name: '‰∏öÁª©È¢ÑË≠¶ÂèëÂ∏É', description: 'ÂÖ¨Âè∏ÂèëÂ∏ÉÁõàÂà©È¢ÑË≠¶ÔºåËÇ°‰ª∑Êö¥Ë∑åÔºÅ' },
            { name: 'ÈÄÄÂ∏ÇÈ£éÈô©Ë≠¶Âëä', description: 'ÂÖ¨Âè∏Èù¢‰∏¥ÈÄÄÂ∏ÇÈ£éÈô©ÔºåÊäïËµÑËÄÖÊÅêÊÖåÔºÅ' },
            { name: 'ÂõΩÈôÖÂà∂Ë£ÅÂçáÁ∫ß', description: 'ÂèóÂà∞ÂõΩÈôÖÂà∂Ë£ÅÔºåÊµ∑Â§ñ‰∏öÂä°ÂèóÈòªÔºÅ' },
            { name: 'Ë¥ßÂ∏ÅË¥¨ÂÄº', description: 'Êú¨Â∏ÅÂ§ßÂπÖË¥¨ÂÄºÔºåËøõÂè£ÊàêÊú¨Â¢ûÂä†ÔºÅ' },
            { name: 'Âà©Áéá‰∏äË∞É', description: 'Â§ÆË°åÂä†ÊÅØÔºå‰ºÅ‰∏öËûçËµÑÊàêÊú¨‰∏äÂçáÔºÅ' },
            { name: 'ÈÄöË¥ßÁ¥ßÁº©ÊãÖÂøß', description: 'Áâ©‰ª∑ÊåÅÁª≠‰∏ãË∑åÔºåÊ∂àË¥πÊ¨≤ÊúõÂáèÂº±ÔºÅ' },
            { name: 'ÁΩ¢Â∑•ÊΩÆËîìÂª∂', description: 'Â§ö‰∏™Ë°å‰∏öÁàÜÂèëÁΩ¢Â∑•ÔºåÁ§æ‰ºöÁß©Â∫èÂèóÂà∞ÂΩ±ÂìçÔºÅ' },
            { name: 'Á†¥‰∫ßÊΩÆÊ∂åÁé∞', 'description': 'Â§ßÈáè‰∏≠Â∞è‰ºÅ‰∏öÂÄíÈó≠ÔºåÂ§±‰∏öÁéáÈ£ôÂçáÔºÅ' },
            { name: 'ÈªëÂ§©ÈπÖ‰∫ã‰ª∂', description: '‰∏çÂèØÈ¢ÑÊµãÁöÑÁ™ÅÂèë‰∫ã‰ª∂ÔºåÂ∏ÇÂú∫ÂâßÁÉàÂä®Ëç°ÔºÅ' },
            { name: 'ËÉΩÊ∫êÂç±Êú∫', description: 'ÂÖ®ÁêÉËÉΩÊ∫ê‰æõÂ∫îÁ¥ßÂº†ÔºåÂ∑•‰∏öÁîü‰∫ßÂèóÈôêÔºÅ' },
            { name: 'Á≤ÆÈ£üÂç±Êú∫', description: 'ÂÜú‰ΩúÁâ©Ê≠âÊî∂ÔºåÈ£üÂìÅ‰ª∑Ê†ºÊö¥Ê∂®ÔºÅ' },
            { name: 'Ê∞¥ËµÑÊ∫êÁü≠Áº∫', description: 'Âπ≤Êó±ÂØºËá¥Ê∞¥ËµÑÊ∫êÂåÆ‰πèÔºåÂÜú‰∏öÁîü‰∫ßÂèóÊå´ÔºÅ' },
            { name: 'Á§æ‰ºöÂä®Ëç°', description: 'Á§æ‰ºöÁüõÁõæÊøÄÂåñÔºåÂΩ±ÂìçÁªèÊµéÁ®≥ÂÆöÔºÅ' },
            { name: 'ÊäÄÊúØÊ≥ÑÈú≤', description: 'Ê†∏ÂøÉÊäÄÊúØË¢´ÁõóÂèñÔºåÁ´û‰∫â‰ºòÂäø‰∏ßÂ§±ÔºÅ' },
            { name: 'Êï∞ÊçÆÈöêÁßÅ‰∏ëÈóª', description: 'Áî®Êà∑Êï∞ÊçÆÊ≥ÑÈú≤ÔºåÂºïÂèëÂπøÊ≥õÂÖ≥Ê≥®Âíå‰ø°‰ªªÂç±Êú∫ÔºÅ' },
            { name: 'AI‰º¶ÁêÜÈóÆÈ¢ò', description: '‰∫∫Â∑•Êô∫ËÉΩÂèëÂ±ïÈÅ≠ÈÅá‰º¶ÁêÜÊåëÊàòÔºåÂºïÂèë‰∫âËÆÆÔºÅ' },
            { name: 'Â§™Á©∫ÂûÉÂúæÂ®ÅËÉÅ', description: 'Â§™Á©∫Á¢éÁâáÈóÆÈ¢òÊó•Áõä‰∏•ÈáçÔºåÂ®ÅËÉÅÂç´ÊòüÂÆâÂÖ®ÔºÅ' },
            { name: 'ÁîüÁâ©Ê≠¶Âô®Â®ÅËÉÅ', description: 'ÁîüÁâ©ÁßëÊäÄÊª•Áî®ÔºåÂºïÂèëÂÖ®ÁêÉÊÅêÊÖåÔºÅ' },
            { name: 'ÊûÅÁ´ØÂ§©Ê∞î‰∫ã‰ª∂', description: 'ÂÖ®ÁêÉÊ∞îÂÄôÂèòÊöñÔºåÊûÅÁ´ØÂ§©Ê∞îÈ¢ëÂèëÔºåÂΩ±ÂìçÁîü‰∫ßÁîüÊ¥ªÔºÅ' },
            { name: 'ÂÖªËÄÅÈáëÂç±Êú∫', description: '‰∫∫Âè£ËÄÅÈæÑÂåñÂä†ÂâßÔºåÂÖªËÄÅÈáë‰ΩìÁ≥ªÈù¢‰∏¥Â¥©Ê∫ÉÔºÅ' },
            { name: 'ÊïôËÇ≤Á≥ªÁªüÂ¥©Ê∫É', description: 'ÊïôËÇ≤ËµÑÊ∫êÂàÜÈÖç‰∏çÂùáÔºåÁ§æ‰ºöÂÖ¨Âπ≥ÊÄßÂèóÊçüÔºÅ' },
            { name: 'ÂåªÁñóÁ≥ªÁªüË∂ÖËΩΩ', description: 'ÂÖ¨ÂÖ±Âç´Áîü‰∫ã‰ª∂ÂØºËá¥ÂåªÁñóËµÑÊ∫êËÄóÂ∞ΩÔºÅ' },
            { name: 'ÂüéÂ∏ÇÂü∫Á°ÄËÆæÊñΩËÄÅÂåñ', description: 'ÂüéÂ∏ÇÁÆ°ÁΩëÁ†¥Ë£ÇÔºå‰∫§ÈÄöÊã•Â†µÔºåÂΩ±ÂìçÊ∞ëÁîüÔºÅ' },
            { name: 'Ê†∏Ê≥ÑÊºè‰∫ãÊïÖ', description: 'Ê†∏ÁîµÁ´ôÂèëÁîüÊ≥ÑÊºèÔºåÈÄ†ÊàêÁéØÂ¢ÉÁÅæÈöæÔºÅ' }
        ];

        additionalPositiveEvents.forEach(event => {
            marketEvents.push({
                type: 'positive',
                name: event.name,
                description: event.description,
                effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN,
                icon: '‚ú®' // Generic positive icon
            });
        });

        additionalNegativeEvents.forEach(event => {
            marketEvents.push({
                type: 'negative',
                name: event.name,
                description: event.description,
                effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN),
                icon: 'üëé' // Generic negative icon
            });
        });

        // --- Game State Variables ---
        let cash = 0;
        let currentDay = 0;
        let stocks = [];
        let gameRunning = false;
        let swipeStartY = 0;
        let isSwiping = false;
        let previousPrices = {}; // Stores previous day's closing prices for fluctuation comparison
        let aiBoughtPrices = {}; // AI's internal tracking of assumed buy price for owned stocks (for its strategy)
        let aiTradeHistory = []; // Stores AI trade records
        let lastMarketEventHappened = []; // Stores the actual market event that happened on the current day, initialized as array
        let totalTrades = 0; // New: Total number of buy/sell transactions
        let totalFees = 0;   // New: Total transaction fees paid
        let activeStrategyName = "ÊâãÂä®Êìç‰Ωú"; // New: Default to manual operation
        let peakNetWorth = INITIAL_CASH; // New: Initialize at declaration
        let troughNetWorth = INITIAL_CASH; // New: Initialize at declaration

        // Store historical prices for SMA calculations for each stock
        let historicalPrices = {}; // { stockName: [price1, price2, ...]}

        // --- UI Elements ---
        const loadingScreen = document.getElementById('loadingScreen');
        const gameContainer = document.getElementById('gameContainer');
        const currentDayDisplay = document.getElementById('currentDay');
        const cashDisplay = document.getElementById('cashDisplay');
        const portfolioValueDisplay = document.getElementById('portfolioValueDisplay');
        const netWorthDisplay = document.getElementById('netWorthDisplay');
        const stockTableBody = document.getElementById('stockTableBody');
        const nextDayButton = document.getElementById('nextDayButton');
        const logElement = document.getElementById('log');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const initialCapitalResult = document.getElementById('initialCapitalResult');
        const finalNetWorthResult = document.getElementById('finalNetWorthResult');
        const profitLossResult = document.getElementById('profitLossResult');
        const playerTitleDisplay = document.getElementById('playerTitle');
        const playAgainButton = document.getElementById('playAgainButton');
        const aiTradeHistoryDisplay = document.getElementById('aiTradeHistoryDisplay');
        const buyAllStocksButton = document.getElementById('buyAllStocksButton');
        const sellAllButton = document.getElementById('sellAllButton');
        const sellHalfButton = document.getElementById('sellHalfButton');
        const sellQuarterButton = document.getElementById('sellQuarterButton');
        const profitLossPercentageResult = document.getElementById('profitLossPercentageResult');
        const usedStrategyDisplay = document.getElementById('usedStrategyDisplay');
        const peakNetWorthDisplay = document.getElementById('peakNetWorthDisplay');
        const troughNetWorthDisplay = document.getElementById('troughNetWorthDisplay');

        // New: Custom Stock Addition Elements
        const newStockNameInput = document.getElementById('newStockName');
        const newStockCodeInput = document.getElementById('newStockCode');
        const newStockPriceInput = document.getElementById('newStockPrice');
        const addStockButton = document.getElementById('addStockButton');

        // New: Help Modal UI Elements
        const helpIcon = document.getElementById('helpIcon');
        const strategyHelpModal = document.getElementById('strategyHelpModal');
        const closeButton = document.querySelector('#strategyHelpModal .close-button');
        const strategyExplanationContent = document.getElementById('strategyExplanationContent');

        // --- Helper Functions ---
        function formatCurrency(amount) {
            return '¬•' + amount.toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&');
        }

        function logMessage(message, type = 'info', icon = '', doNotLog = false) {
            // Option to suppress logging for performance during rapid events (e.g., AI sim)
            if (doNotLog) return;

            const p = document.createElement('p');
            p.className = 'fade-in';
            let formattedMessage = '';

            switch(type) {
                case 'error': p.style.color = 'var(--danger-color)'; p.style.fontWeight = 'bold'; formattedMessage = `${icon || '‚ùå'} ${message}`; break;
                case 'success': p.style.color = 'var(--success-color)'; formattedMessage = `${icon || '‚úÖ'} ${message}`; break;
                case 'warn': p.style.color = 'var(--warning-color)'; formattedMessage = `${icon || '‚ö†Ô∏è'} ${message}`; break;
                case 'profit': p.style.color = 'var(--profit-color)'; p.style.fontWeight = 'bold'; formattedMessage = `${icon || 'üí∞'} ${message}`; break;
                case 'loss': p.style.color = 'var(--loss-color)'; p.style.fontWeight = 'bold'; formattedMessage = `${icon || 'üìâ'} ${message}`; break;
                case 'event': p.style.color = 'var(--event-color)'; p.style.fontWeight = 'bold'; formattedMessage = `${icon} „ÄêÂ∏ÇÂú∫‰∫ã‰ª∂„Äë ${message}`; break;
                case 'ai': p.style.color = 'var(--secondary-color)'; formattedMessage = `${icon || 'ü§ñ'} ${message}`; break;
                default: p.style.color = 'var(--dark-color)'; formattedMessage = `${icon} ${message}`;
            }
            p.innerHTML = formattedMessage;

            logElement.appendChild(p);
            logElement.scrollTop = logElement.scrollHeight;

            // Limit log size to prevent performance issues on long games
            if (logElement.children.length > 50) {
                logElement.removeChild(logElement.children[0]);
            }
        }

        // New function to generate realistic stock names and codes for A-shares
        function generateRealisticStockData() {
            const prefixes = ["‰∏≠", "Âçé", "Âåó", "Âçó", "‰∏ú", "Ë•ø", "Â§ß", "Â∞è", "Èáë", "Èì∂", "Áßë", "Âàõ", "ÈÄö", "‰ø°", "ÂÆâ", "Êµ∑", "‰∫ë", "Êô∫", "ÂÖâ", "Áëû", "Âçö", "ÊôÆ", "Êñ∞", "ÂõΩ", "Â§©", "Èæô", "Âá§", "ËÖæ", "Ëææ", "ËÅî"];
            const suffixes = ["ÁßëÊäÄ", "ËÇ°‰ªΩ", "‰ø°ÊÅØ", "Êô∫ËÉΩ", "ÈõÜÂõ¢", "ÁîüÁâ©", "ËÉΩÊ∫ê", "ÊùêÊñô", "ÁΩëÁªú", "ÁîµÂ≠ê", "ÈáëËûç", "ÊäïËµÑ", "ËµÑÊú¨", "ËØÅÂà∏", "ÂåñÂ∑•", "ÂåªËçØ", "Êú∫Ê¢∞", "Ê±ΩËΩ¶", "ÁîµÂäõ", "ÂÜú‰∏ö", "Áâ©ÊµÅ", "ÁéØ‰øù", "‰º†Â™í", "ËΩØ‰ª∂", "ÂçäÂØº‰Ωì", "Êñ∞ËÉΩÊ∫ê", "ÂÜõÂ∑•", "Âú∞‰∫ß", "Ê∂àË¥π", "Èõ∂ÂîÆ"];
            
            const randomPrefix = prefixes[Math.floor(Math.random() * prefixes.length)];
            const randomSuffix = suffixes[Math.floor(Math.random() * suffixes.length)];

            let name = `${randomPrefix}${randomSuffix}`;
            if (Math.random() < 0.3) { // 30% chance to add a middle part
                const middlePart = ["Êó∂‰ª£", "‰∏ñÁ∫™", "ÂèëÂ±ï", "ÂÆû‰∏ö", "ÂõΩÈôÖ", "ËÅîÂêà", "ÊéßËÇ°"][Math.floor(Math.random() * 7)];
                name = `${randomPrefix}${middlePart}${randomSuffix}`;
            }
            if (Math.random() < 0.2) { // 20% chance to add a number to the name
                name += (Math.floor(Math.random() * 90) + 10); // Add a 2-digit number
            }

            // A-share code generation: 6 digits
            // Shanghai Main Board: 60xxxx
            // Shenzhen Main Board: 00xxxx
            // ChiNext (Âàõ‰∏öÊùø): 30xxxx
            // STAR Market (ÁßëÂàõÊùø): 688xxx
            const codeStarts = ['60', '00', '30', '688'];
            const codeStart = codeStarts[Math.floor(Math.random() * codeStarts.length)];

            let remainingDigitsCount = 6 - codeStart.length;
            let codeBody = '';
            for (let i = 0; i < remainingDigitsCount; i++) {
                codeBody += Math.floor(Math.random() * 10);
            }
            const code = codeStart + codeBody;

            const initialPrice = parseFloat((Math.random() * (INITIAL_PRICE_MAX - INITIAL_PRICE_MIN) + INITIAL_PRICE_MIN).toFixed(2));

            return {
                name: name,
                code: code,
                price: initialPrice,
                sharesOwned: 0,
                basePrice: initialPrice,
                growthFactor: 0, // Will be set globally or in loop later
                previousDayChangePercent: 0
            };
        }

        function generateRandomName() { // Keep this for legacy or if used elsewhere, though generateRealisticStockData is preferred
            const prefixes = ["Áßë", "Áëû", "Âçé", "Âçö", "Âàõ", "‰ø°", "ÈÄö", "ÂÆâ", "Êµ∑", "‰∫ë", "Êô∫", "ÂÖâ", "Èáë", "Èì∂", "Èæô", "Ëôé"];
            const middles = ["Ëææ", "ËÆØ", "Ëøú", "ËäØ", "Áõõ", "Ê≥∞", "Â∫∑", "ÂæÆ", "Êñ∞", "ÊÅí", "ÊôÆ", "Ê≠£", "ÂØå", "Ë¥µ", "Ë¥¢", "Ê∫ê"];
            const suffixes = ["ÁßëÊäÄ", "ËÇ°‰ªΩ", "‰ø°ÊÅØ", "Êô∫ËÉΩ", "ÈõÜÂõ¢", "ÁîüÁâ©", "ËÉΩÊ∫ê", "ÊùêÊñô", "ÁΩëÁªú", "ÁîµÂ≠ê", "ÈáëËûç", "ÊäïËµÑ", "ËµÑÊú¨", "ËØÅÂà∏", "Âü∫Èáë", "Èì∂Ë°å"];
            const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
            const middle = middles[Math.floor(Math.random() * middles.length)];
            const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
            const num = Math.floor(Math.random() * 900) + 100;
            if (Math.random() > 0.4) return `${prefix}${middle}${suffix}(${num})`;
            else return `${prefix}${suffix}(${num})`;
        }

        function calculatePortfolioValue() {
            return stocks.reduce((total, stock) => total + (stock.price * stock.sharesOwned), 0);
        }

        function calculateNetWorth() {
            return cash + calculatePortfolioValue();
        }

        // --- UI Update Functions ---
        function updateUI() {
            currentDayDisplay.textContent = currentDay;
            cashDisplay.textContent = formatCurrency(cash);
            const portfolioValue = calculatePortfolioValue();
            portfolioValueDisplay.textContent = formatCurrency(portfolioValue);
            const netWorth = cash + portfolioValue;
            netWorthDisplay.textContent = formatCurrency(netWorth);

            // Update peak and trough net worth
            if (netWorth > peakNetWorth) {
                peakNetWorth = netWorth;
            }
            if (netWorth < troughNetWorth) {
                troughNetWorth = netWorth;
            }

            if (currentDay > 0) {
                // Add a slight animation for money updates
                cashDisplay.classList.add('pulse');
                portfolioValueDisplay.classList.add('pulse');
                netWorthDisplay.classList.add('pulse');
                setTimeout(() => {
                    cashDisplay.classList.remove('pulse');
                    portfolioValueDisplay.classList.remove('pulse');
                    netWorthDisplay.classList.remove('pulse');
                }, 500);
            }
            // Ensure action buttons are always up-to-date after UI updates
            renderStockTable();
        }

        function renderStockTable() {
            stockTableBody.innerHTML = '';
            stocks.forEach((stock, index) => {
                const row = stockTableBody.insertRow();
                const sharesOwned = stock.sharesOwned;
                const currentPrice = stock.price;
                const prevPrice = previousPrices[stock.name];

                let priceChangeClass = 'price-unchanged';
                if (previousPrices[stock.name] !== undefined && previousPrices[stock.name] !== null) {
                    if (currentPrice > previousPrices[stock.name]) priceChangeClass = 'price-up';
                    else if (currentPrice < previousPrices[stock.name]) priceChangeClass = 'price-down';
                }

                // Extract stock name and code (prioritize new 'code' property)
                let stockName = stock.name;
                let stockCode = '';

                if (stock.code) {
                    stockCode = stock.code;
                } else {
                    const nameMatch = stock.name.match(/^(.*)\((\d+)\)$/);
                    if (nameMatch) {
                        stockName = nameMatch[1];
                        stockCode = nameMatch[2];
                    }
                }

                // Format stock code to be 6 digits with leading zeros
                const formattedStockCode = stockCode ? stockCode.padStart(6, '0') : '';

                // Calculate percentage change
                let percentageChange = 0;
                if (prevPrice !== undefined && prevPrice !== null && prevPrice > 0) {
                    percentageChange = ((currentPrice - prevPrice) / prevPrice) * 100;
                }

                // Format percentage change and determine class
                const formattedPercentageChange = percentageChange.toFixed(2) + '%';
                let percentageChangeClass = 'price-unchanged';
                if (percentageChange > 0) percentageChangeClass = 'price-up';
                else if (percentageChange < 0) percentageChangeClass = 'price-down';

                row.innerHTML = `
                    <td class="stock-name">${stockName}</td>
                    <td class="number">${formattedStockCode}</td>
                    <td class="currency ${priceChangeClass}">${formatCurrency(currentPrice)}</td>
                    <td class="currency ${percentageChangeClass}">${formattedPercentageChange}</td>
                    <td class="number">${sharesOwned}</td>
                    <td class="currency">${formatCurrency(currentPrice * sharesOwned)}</td>
                    <td class="stock-actions action-cell">
                        <input type="number" id="qty-${index}" inputmode="numeric" pattern="[0-9]*" placeholder="Êï∞Èáè(${DEFAULT_TRADE_QUANTITY})" title="Âêë‰∏äÊªëÂä®Â¢ûÂä†${SWIPE_INCREMENT_QUANTITY}ËÇ°">
                        <button class="buy-button" data-index="${index}" ${cash < currentPrice * MIN_PRICE ? 'disabled' : ''} title="‰π∞ÂÖ•ËÇ°Á•®">‰π∞</button>
                        <button class="sell-button" data-index="${index}" ${sharesOwned === 0 ? 'disabled' : ''} title="ÂçñÂá∫ËÇ°Á•®">Âçñ</button>
                        <button class="close-button" data-index="${index}" ${sharesOwned === 0 ? 'disabled' : ''} title="ÂçñÂá∫ÂÖ®ÈÉ® ${sharesOwned} ËÇ°">Âπ≥‰ªì</button>
                    </td>
                `;
                // Update previous price AFTER rendering the row with comparison class
                // REMOVED: previousPrices[stock.name] = currentPrice;
            });
            attachActionListeners();
        }

        // --- Game Logic Functions ---
        function initializeGame() {
            logElement.innerHTML = ''; // Clear previous log
            logMessage("üéâ Ê¨¢ËøéÊù•Âà∞ÂçéÂ∞îË°ó‰πãÁãºÊ®°ÊãüÂô® v4ÔºÅ", 'info');
            logMessage("üí° ÊèêÁ§∫ÔºöÊÇ®Â∑≤Â∞ÜÂàùÂßãËÇ°Á•®Êï∞ÈáèËÆæÁΩÆ‰∏∫0„ÄÇËØ∑‰ΩøÁî®‰∏ãÊñπ'Ëá™Ë°åÊ∑ªÂä†ËÇ°Á•®'ÂäüËÉΩÊ∑ªÂä†ÊÇ®ÁöÑËÇ°Á•®„ÄÇÊàñËÄÖÔºåÊ∏∏ÊàèÂ∑≤‰∏∫ÊÇ®Âä†ËΩΩ‰∫Ü 300 Âè™ÈªòËÆ§ËÇ°Á•®ÔºÅ", 'info'); // Updated log message

            cash = INITIAL_CASH;
            currentDay = 0;
            stocks = [];
            gameRunning = false;
            previousPrices = {};
            aiBoughtPrices = {}; // Reset AI's internal buy prices
            aiTradeHistory = []; // Reset AI trade history
            lastMarketEventHappened = []; // Reset for a new game, ensure it's an array
            totalTrades = 0; // Reset total trades
            totalFees = 0;   // Reset total fees
            activeStrategyName = "ÊâãÂä®Êìç‰Ωú"; // Reset for a new game
            peakNetWorth = INITIAL_CASH; // Reset for a new game
            troughNetWorth = INITIAL_CASH; // Reset for a new game

            gameOverScreen.style.display = 'none';
            nextDayButton.disabled = false;
            // Disable all strategy buttons until game starts
            strategy1Button.disabled = true;
            strategy2Button.disabled = true;
            strategy3Button.disabled = true;
            strategy4Button.disabled = true;
            strategy5Button.disabled = true;
            strategy6Button.disabled = true;
            strategy7Button.disabled = true;
            strategy8Button.disabled = true;

            buyAllStocksButton.disabled = true; // Disable until game starts
            sellAllButton.disabled = true; // Disable until game starts
            sellHalfButton.disabled = true; // Disable until game starts
            sellQuarterButton.disabled = true; // Disable until game starts
            nextDayButton.textContent = "ÂºÄÂßãÊ∏∏Êàè";

            // --- Load stocks from localStorage ---
            const savedStocks = localStorage.getItem('customStocks');
            if (savedStocks) {
                try {
                    const parsedStocks = JSON.parse(savedStocks);
                    // Ensure loaded stocks have all necessary properties for new game
                    stocks = parsedStocks.map(s => ({
                        name: s.name,
                        code: s.code,
                        price: s.price,
                        sharesOwned: 0, // Always reset sharesOwned for a new game
                        basePrice: s.price, // Reset basePrice to loaded price
                        growthFactor: 0, // Will be assigned below
                        previousDayChangePercent: 0
                    }));
                    // Initialize historical prices for loaded stocks
                    stocks.forEach(s => {
                        historicalPrices[s.name] = [s.price];
                        previousPrices[s.name] = s.price; // Also set initial previous price for consistency
                    });
                    logMessage(`Â∑≤Âä†ËΩΩ ${stocks.length} Âè™Ëá™ÂÆö‰πâËÇ°Á•®„ÄÇ`, 'info', 'üìÅ');
                } catch (e) {
                    console.error("Failed to parse saved stocks from localStorage:", e);
                    logMessage("Âä†ËΩΩ‰øùÂ≠òÁöÑËÇ°Á•®Â§±Ë¥•ÔºåÂ∞Ü‰ªéÈõ∂ÂºÄÂßã„ÄÇ", 'error', '‚ùå');
                }
            } 
            
            // If no saved stocks were loaded (or failed to load), generate default ones
            if (stocks.length === 0) {
                const defaultStockCount = 300; // Generate 300 stocks
                logMessage(`Êú™ÊâæÂà∞Â∑≤‰øùÂ≠òÁöÑËá™ÂÆö‰πâËÇ°Á•®„ÄÇÊ≠£Âú®ÁîüÊàê ${defaultStockCount} Âè™ÈªòËÆ§ËÇ°Á•®...`, 'info', '‚ú®');
                for (let i = 0; i < defaultStockCount; i++) {
                    let newStock;
                    let isUnique = false;
                    let attempts = 0;
                    // Try to ensure unique names/codes for generated stocks
                    while (!isUnique && attempts < 100) { // Limit attempts to prevent infinite loop
                        newStock = generateRealisticStockData();
                        if (!stocks.some(s => s.name === newStock.name || s.code === newStock.code)) {
                            isUnique = true;
                        }
                        attempts++;
                    }
                    if (isUnique) {
                        stocks.push(newStock);
                        historicalPrices[newStock.name] = [newStock.price];
                        previousPrices[newStock.name] = newStock.price;
                    } else {
                        // Fallback: If unable to find a unique name/code after many attempts,
                        // add a non-unique one (unlikely with this large pool, but for robustness)
                        console.warn("Could not generate a unique stock after several attempts. Adding with potential duplicate.");
                        stocks.push(newStock);
                        historicalPrices[newStock.name] = [newStock.price];
                        previousPrices[newStock.name] = newStock.price;
                    }
                }
                logMessage(`Â∑≤ÁîüÊàê ${stocks.length} Âè™ÈªòËÆ§ËÇ°Á•®„ÄÇ`, 'success', '‚úÖ');
            }
            
            // Assign growthFactor to all stocks (loaded or newly generated)
            stocks.forEach(stock => {
                stock.growthFactor = (Math.random() * (BASE_PRICE_GROWTH_RATE_MAX - BASE_PRICE_GROWTH_RATE_MIN) + BASE_PRICE_GROWTH_RATE_MIN) / 365;
            });
            stocks.sort((a, b) => a.name.localeCompare(b.name)); // Ensure sorted after load/addition

            updateUI();

            // Hide loading screen and show game container after a short delay
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                gameContainer.style.display = 'block';
            }, 1000); // Simulate loading time
        }

        function updateStockPrices() {
            let marketTrend = 0;
            stocks.forEach(stock => {
                // Store the *current* price before calculating the new one for comparison
                previousPrices[stock.name] = stock.price;
                historicalPrices[stock.name].push(stock.price);
                // Keep historical data array size limited to prevent excessive memory usage
                if (historicalPrices[stock.name].length > Math.max(TREND_FOLLOW_SMA_PERIOD, MEAN_REVERSION_SMA_PERIOD) * 2) {
                    historicalPrices[stock.name].shift(); // Remove oldest price
                }

                // 1. Base Price Growth (Intrinsic Value)
                stock.basePrice = stock.basePrice * (1 + stock.growthFactor); // Compound daily

                // 2. Momentum Effect
                const momentumEffect = stock.previousDayChangePercent * MOMENTUM_FACTOR;

                // 3. Random Fluctuation (reduced impact)
                const randomFluctuation = (Math.random() * 2 - 1) * (MAX_PRICE_FLUCTUATION_PERCENT / 2); // Reduced random fluctuation

                // Combine effects
                const totalChangePercent = momentumEffect + randomFluctuation;
                let newPrice = stock.price * (1 + totalChangePercent / 100);

                // Add marketTrend from previous logic (sum up for overall market trend)
                marketTrend += totalChangePercent;

                // Small chance of significant random volatility (unrelated to market events) - keep this for realism
                if (Math.random() < 0.03) {
                    const bigJumpPercent = (Math.random() * 2 - 1) * MAX_PRICE_FLUCTUATION_PERCENT * 2.5;
                    newPrice = stock.price * (1 + bigJumpPercent / 100);
                    logMessage(`„ÄêÂ∏ÇÂú∫Ê≥¢Âä®„Äë${stock.name} ‰ª∑Ê†ºÂâßÁÉàÊ≥¢Âä®!`, 'warn', 'üí•', true); // Suppress logging for performance
                }

                newPrice = Math.max(MIN_PRICE, parseFloat(newPrice.toFixed(2)));

                // Calculate actual percentage change for next day's momentum
                stock.previousDayChangePercent = ((newPrice - stock.price) / stock.price) * 100;

                stock.price = newPrice;
            });

            // Apply overall market trend based on average daily stock changes - keep this
            // Use stocks.length instead of NUM_STOCKS to account for user-added stocks
            if (stocks.length > 0) { // Prevent division by zero if no stocks at all
                marketTrend = marketTrend / stocks.length * 0.3; // Less impactful overall trend
                if (Math.abs(marketTrend) > 0.5) {
                    stocks.forEach(stock => {
                        stock.price = Math.max(MIN_PRICE, parseFloat((stock.price * (1 + marketTrend / 100)).toFixed(2)));
                    });
                    logMessage(marketTrend > 0 ? `üìà Â∏ÇÂú∫Êï¥‰ΩìÂëàÁé∞‰∏äÊ∂®Ë∂ãÂäø` : `üìâ Â∏ÇÂú∫Êï¥‰ΩìÂëàÁé∞‰∏ãË∑åË∂ãÂäø`, marketTrend > 0 ? 'profit' : 'loss', '', true); // Suppress logging for performance
                }
            } else {
                // If there are no stocks, the marketTrend calculation doesn't make sense
                // and should be skipped to prevent NaN/Infinity.
                marketTrend = 0; // Reset or ensure it's not used in a way that causes issues
            }

            // --- Introduce Market Events (Per Stock) ---
            const currentDayEvents = []; // Collect all events that happen on this day
            if (currentDay > 10) { // Only after some initial days
                stocks.forEach(stock => {
                    if (Math.random() < PER_STOCK_EVENT_PROBABILITY) {
                        const event = marketEvents[Math.floor(Math.random() * marketEvents.length)];
                        const priceEffect = event.effect(stock); // Calculate percentage change for this specific stock

                        stock.price = Math.max(MIN_PRICE, parseFloat((stock.price * (1 + priceEffect / 100)).toFixed(2)));
                        
                        currentDayEvents.push({ event: event, stock: stock, priceEffect: priceEffect });
                        logMessage(`${event.icon} „Äê${event.name}„Äë ${stock.name}: ${event.description} ‰ª∑Ê†º${priceEffect > 0 ? '‰∏äÊ∂®' : '‰∏ãË∑å'} ${Math.abs(priceEffect).toFixed(1)}%!`, 'event', '', false); // Log event for each stock
                    }
                });
            }
            lastMarketEventHappened = currentDayEvents; // Store all events that happened today
        }

        function getQuantity(inputElement) {
            const value = inputElement.value.trim();
            const parsedValue = parseInt(value);
            if (value === '' || isNaN(parsedValue) || parsedValue <= 0) {
                // For player actions, using a default when nothing is entered is good UX.
                // For AI, quantities are typically calculated within its logic.
                return DEFAULT_TRADE_QUANTITY;
            }
            return parsedValue;
        }

        function buyStock(index, quantity, isAI = false, updateImmediate = true) {
            if (!gameRunning || quantity <= 0) return false;
            const stock = stocks[index];
            const cost = stock.price * quantity;
            const transactionFee = cost * (TRANSACTION_FEE_PERCENT / 100); // Calculate fee

            if (cash >= cost + transactionFee) { // Check if cash is enough for cost + fee
                // Update AI's assumed average buy price (still used for AI trade history display)
                if (isAI) {
                    const currentTotalCost = (aiBoughtPrices[stock.name] || 0) * stock.sharesOwned;
                    aiBoughtPrices[stock.name] = (currentTotalCost + cost) / (stock.sharesOwned + quantity);
                    // Record AI trade
                    aiTradeHistory.push({
                        day: currentDay,
                        type: 'Buy',
                        stockName: stock.name,
                        quantity: quantity,
                        price: stock.price
                    });
                }

                cash -= (cost + transactionFee); // Deduct cost and fee
                stock.sharesOwned += quantity;
                totalTrades++; // Increment total trades
                totalFees += transactionFee; // Add to total fees

                // Only log detailed buy if not AI (AI logs its own decision)
                if (!isAI) {
                    logMessage(`‰π∞ÂÖ• ${quantity} ËÇ° ${stock.name} @ ${formatCurrency(stock.price)}„ÄÇËä±Ë¥π: ${formatCurrency(cost)} (Âê´Á®éË¥π: ${formatCurrency(transactionFee)})`, 'success', '‚úÖ');
                }
                if (updateImmediate) updateUI();
                return true;
            } else {
                if (!isAI) logMessage(`ËµÑÈáë‰∏çË∂≥‰π∞ÂÖ• ${quantity} ËÇ° ${stock.name}„ÄÇÈúÄË¶Å ${formatCurrency(cost + transactionFee)}ÔºåÁé∞Êúâ ${formatCurrency(cash)}„ÄÇ`, 'error', '‚ùå');
                return false;
            }
        }

        function sellStock(index, quantity, isAI = false, updateImmediate = true) {
            if (!gameRunning || quantity <= 0) return false;
            const stock = stocks[index];
            if (stock.sharesOwned >= quantity) {
                const earnings = stock.price * quantity;
                const transactionFee = earnings * (TRANSACTION_FEE_PERCENT / 100); // Calculate fee

                cash += (earnings - transactionFee); // Add earnings, deduct fee
                stock.sharesOwned -= quantity;
                totalTrades++; // Increment total trades
                totalFees += transactionFee; // Add to total fees

                // If AI sells all shares, remove from aiBoughtPrices
                if (isAI) {
                    if (stock.sharesOwned === 0 && aiBoughtPrices[stock.name]) {
                        delete aiBoughtPrices[stock.name];
                    }
                    // Record AI trade
                    aiTradeHistory.push({
                        day: currentDay,
                        type: 'Sell',
                        stockName: stock.name,
                        quantity: quantity,
                        price: stock.price
                    });
                }
                 // If AI sells partial, and we're tracking average, might need to re-calculate, but simplified it's just removed when shares hit 0

                // Only log detailed sell if not AI (AI logs its own decision)
                if (!isAI) {
                    logMessage(`ÂçñÂá∫ ${quantity} ËÇ° ${stock.name} @ ${formatCurrency(stock.price)}„ÄÇËé∑Âæó: ${formatCurrency(earnings)} (Êâ£Èô§Á®éË¥π: ${formatCurrency(transactionFee)})`, 'success', 'üìà');
                }
                if (updateImmediate) updateUI();
                return true;
            } else {
                if (!isAI) logMessage(`Êó†Ê≥ïÂçñÂá∫ ${quantity} ËÇ° ${stock.name}ÔºåÂè™ÊåÅÊúâ ${stock.sharesOwned} ËÇ°„ÄÇ`, 'error', 'üö´');
                return false;
            }
        }

        function closePosition(index) {
            const stock = stocks[index];
            if (stock.sharesOwned > 0) {
                logMessage(`Ê≠£Âú®Âπ≥‰ªì ${stock.name} (ÂÖ± ${stock.sharesOwned} ËÇ°)...`, 'info', '‚ö°');
                sellStock(index, stock.sharesOwned, false, true); // Close position is a manual action, update immediately
            } else {
                logMessage(`Êó†Ê≥ïÂπ≥‰ªì ${stock.name}ÔºåÊú™ÊåÅÊúâËØ•ËÇ°Á•®„ÄÇ`, 'warn', '‚ö†Ô∏è');
            }
        }

        function nextDay() {
            if (!gameRunning && currentDay === 0) {
                logMessage("Ê∏∏ÊàèÊ≠£ÂºèÂºÄÂßã! Day 0„ÄÇ", 'info');
                logMessage("Â∏ÇÂú∫Áû¨ÊÅØ‰∏áÂèòÔºåÊäì‰ΩèÊú∫‰ºöÔºåÂàõÈÄ†Ë¥¢ÂØå!", 'info');
                nextDayButton.textContent = "‰∏ã‰∏ÄÂ§©";
                // Enable all strategy buttons after game starts (Day 0)
                strategy1Button.disabled = false;
                strategy2Button.disabled = false;
                strategy3Button.disabled = false;
                strategy4Button.disabled = false;
                strategy5Button.disabled = false;
                strategy6Button.disabled = false;
                strategy7Button.disabled = false;
                strategy8Button.disabled = false;

                buyAllStocksButton.disabled = false; // Enable Buy All Stocks button
                sellAllButton.disabled = false; // Enable bulk sell buttons
                sellHalfButton.disabled = false;
                sellQuarterButton.disabled = false;
                gameRunning = true;
                updateUI(); // Updates currentDay to 0, renders table etc.
                return; // Stop execution, Day 0 display
            }

            if (!gameRunning) return; // Prevent action if game already ended

            // Clear events from previous day before new ones are generated
            lastMarketEventHappened = [];

            if (currentDay >= MAX_DAYS) {
                endGame();
                return;
            }

            currentDay++;
            logMessage(`üìÖ === Á¨¨ ${currentDay} Â§© ===`, 'info');
            updateStockPrices(); // Prices change for the new day
            updateUI(); // Table shows new prices and change indicators

            if (currentDay === MAX_DAYS) {
                logMessage("üéØ ÊúÄÂêé‰∏ÄÂ§©„ÄÇ‰∫§ÊòìÁªìÊùü„ÄÇÁÇπÂáªÊåâÈíÆÊü•ÁúãÊúÄÁªàÁªìÊûú„ÄÇ", 'info', 'üèÅ');
                nextDayButton.textContent = "ÊòæÁ§∫ÁªìÊûú";
                // Disable all strategy buttons on final day
                strategy1Button.disabled = true;
                strategy2Button.disabled = true;
                strategy3Button.disabled = true;
                strategy4Button.disabled = true;
                strategy5Button.disabled = true;
                strategy6Button.disabled = true;
                strategy7Button.disabled = true;
                strategy8Button.disabled = true;
                buyAllStocksButton.disabled = true; // Disable buy all button on final day
                sellAllButton.disabled = true; // Disable bulk sell buttons on final day
                sellHalfButton.disabled = true;
                sellQuarterButton.disabled = true;
            }
        }

        function endGame() {
            gameRunning = false;
            logMessage("üèÅ === Ê∏∏ÊàèÁªìÊùü ===ÔºÅ", 'info');

            // --- Robustness: Ensure cash is a valid number ---
            if (isNaN(cash)) {
                logMessage("‰∏•ÈáçÈîôËØØ: Áé∞ÈáëÂÄºÂèò‰∏∫NaN„ÄÇÂèØËÉΩÂèëÁîü‰∫ÜÂÜÖÈÉ®ËÆ°ÁÆóÈîôËØØ„ÄÇÊ∏∏ÊàèÂ∞ÜÂ∞ùËØï‰ΩøÁî®ÂàùÂßãËµÑÈáëËøõË°åÁªìÁÆó„ÄÇ", 'error', 'üö®');
                cash = INITIAL_CASH; // Reset cash to initial value to attempt recovery
            }

            let liquidationValue = 0;
            stocks.forEach(stock => {
                if (stock.sharesOwned > 0) {
                    const value = stock.price * stock.sharesOwned;
                    if (isNaN(value) || !isFinite(value)) { // Check for NaN or Infinity
                        logMessage(`Ë≠¶Âëä: ËÇ°Á•® ${stock.name} ÁöÑÊ∏ÖÁÆó‰ª∑ÂÄºÊó†Êïà (NaN/Infinity)„ÄÇËØ•ÈÉ®ÂàÜÂ∞Ü‰∏çËÆ°ÂÖ•„ÄÇ`, 'warn', '‚ö†Ô∏è');
                        return; // Skip this stock's value calculation if invalid
                    }
                    liquidationValue += value;
                    logMessage(`üí∏ Âº∫Âà∂Âπ≥‰ªì ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(stock.price)} = ${formatCurrency(value)}`);
                    stock.sharesOwned = 0; // Clear shares after liquidation
                }
            });
            // Ensure liquidationValue is a number before adding to cash
            if (isNaN(liquidationValue) || !isFinite(liquidationValue)) {
                logMessage("Ë≠¶Âëä: ÊÄªÊ∏ÖÁÆó‰ª∑ÂÄºËÆ°ÁÆóÁªìÊûúÊó†Êïà (NaN/Infinity)ÔºåÂ∞ÜËßÜ‰∏∫0„ÄÇ", 'warn', '‚ö†Ô∏è');
                liquidationValue = 0;
            }
            cash += liquidationValue;

            // --- Ensure finalNetWorth is a valid number ---
            let finalNetWorth = calculateNetWorth();
            if (isNaN(finalNetWorth) || !isFinite(finalNetWorth)) { // Check for NaN or Infinity
                logMessage("Ë≠¶Âëä: ÊúÄÁªàËµÑ‰∫ßËÆ°ÁÆóÁªìÊûúÊó†Êïà (NaN/Infinity)„ÄÇÂ∞Ü‰ΩøÁî®ÂΩìÂâçÁé∞ÈáëÂÄº‰Ωú‰∏∫ÊúÄÁªàËµÑ‰∫ß„ÄÇ", 'warn', '‚ö†Ô∏è');
                finalNetWorth = cash; // Fallback to current cash (which we ensured is valid)
            }

            const profitLoss = finalNetWorth - INITIAL_CASH;
            let profitLossPercent = 0;

            // Handle division by zero for profitLossPercent if INITIAL_CASH is 0 (though not the case here)
            // Or if finalNetWorth is equal to INITIAL_CASH (0 profit/loss) to prevent 0/0 = NaN
            if (INITIAL_CASH === 0) {
                if (finalNetWorth === 0) {
                    profitLossPercent = 0; // 0/0 case, or truly no change
                } else {
                    profitLossPercent = Infinity; // Or a very large number, or just show finalNetWorth
                }
            } else {
                profitLossPercent = (finalNetWorth - INITIAL_CASH) / INITIAL_CASH * 100;
            }

            // Ensure profitLossPercent is a number
            if (isNaN(profitLossPercent) || !isFinite(profitLossPercent)) {
                profitLossPercent = 0; // Default to 0 if NaN or Infinity
            }

            initialCapitalResult.textContent = formatCurrency(INITIAL_CASH);
            finalNetWorthResult.textContent = formatCurrency(finalNetWorth);

            if (profitLoss >= 0) {
                profitLossResult.style.color = 'var(--profit-color)';
                profitLossResult.textContent = formatCurrency(profitLoss) + ' üéâ';
                logMessage(`üéä ÊÅ≠Âñú! ÊÇ®Ëé∑Âæó‰∫Ü ${formatCurrency(profitLoss)} ÁöÑÂà©Ê∂¶!`, 'profit');
            } else {
                profitLossResult.style.color = 'var(--loss-color)';
                profitLossResult.textContent = formatCurrency(profitLoss) + ' üò¢';
                logMessage(`üòû ÈÅóÊÜæ! ÊÇ®‰∫èÊçü‰∫Ü ${formatCurrency(-profitLoss)}„ÄÇÂÜçÊé•ÂÜçÂéâ!`, 'loss');
            }

            // Determine player title based on final net worth
            let playerTitle = "Èü≠ËèúÊäïËµÑ‰∫∫ (‰∫èÊçüÂ§ßÊà∑)"; // Default for loss
            if (finalNetWorth > INITIAL_CASH) { // Only calculate percentage if there's a profit
                if (profitLossPercent >= 30) {
                    playerTitle = "Â§©‰πãÈ™ÑÂ≠ê (ËÇ°Â∏Ç‰º†Â•á)";
                } else if (profitLossPercent >= 16) {
                    playerTitle = "ÈáëËûçÂ§ß‰∫® (‰∏ÄÊñπÈú∏‰∏ª)";
                } else if (profitLossPercent >= 11) {
                    playerTitle = "ÊäïËµÑËææ‰∫∫ (Áã¨ÂÖ∑ÊÖßÁúº)";
                } else if (profitLossPercent >= 6) {
                    playerTitle = "Á≤æËã±‰∫§ÊòìÂëò (Â¥≠Èú≤Â§¥Ëßí)";
                } else if (profitLossPercent >= 3) {
                    playerTitle = "Á®≥ÂÅ•ÁêÜË¥¢‰∫∫ (Êî∂ÁõäÂ∞öÂèØ)";
                }
            }
            playerTitleDisplay.textContent = playerTitle;
            logMessage(`ÊÇ®ÁöÑÊúÄÁªàÁß∞Âè∑ÊòØÔºö${playerTitle}`, 'info', 'üèÜ');

            // --- End Display new detailed statistics ---
            profitLossPercentageResult.textContent = `${profitLossPercent.toFixed(2)}%`;
            usedStrategyDisplay.textContent = activeStrategyName;
            peakNetWorthDisplay.textContent = formatCurrency(peakNetWorth);
            troughNetWorthDisplay.textContent = formatCurrency(troughNetWorth);
            // --- End Display new detailed statistics ---

            displayAiTradeHistory(); // Display AI trade history

            // Display new statistics
            document.getElementById('finalTotalTrades').textContent = totalTrades;
            document.getElementById('finalTotalFees').textContent = formatCurrency(totalFees);

            // Ensure all buttons are in correct state at game end
            nextDayButton.disabled = true;
            // Ensure all strategy buttons are disabled after simulation
            strategy1Button.disabled = true;
            strategy2Button.disabled = true;
            strategy3Button.disabled = true;
            strategy4Button.disabled = true;
            strategy5Button.disabled = true;
            strategy6Button.disabled = true;
            strategy7Button.disabled = true;
            strategy8Button.disabled = true;
            
            // Force liquidation of all positions
            stocks.forEach(stock => {
                if (stock.sharesOwned > 0) {
                    const value = stock.price * stock.sharesOwned;
                    cash += value;
                    stock.sharesOwned = 0;
                }
            });
            
            // Final UI update
            updateUI();
            
            // Show game over screen
            gameOverScreen.style.display = 'flex';
            
            // Show confetti if profit
            if (profitLoss > 0 && typeof confetti === 'function') {
                confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
            }
        }

        // Function to display AI trade history
        function displayAiTradeHistory() {
            aiTradeHistoryDisplay.innerHTML = '<h3>AI ‰∫§ÊòìËÆ∞ÂΩï</h3>';
            if (aiTradeHistory.length === 0) {
                aiTradeHistoryDisplay.innerHTML += '<p>AI Êú™ÊâßË°å‰ªª‰Ωï‰∫§Êòì„ÄÇ</p>';
                return;
            }

            const ul = document.createElement('ul');
            aiTradeHistory.forEach(trade => {
                const li = document.createElement('li');
                const actionColor = trade.type === 'Buy' ? 'var(--profit-color)' : 'var(--loss-color)';
                li.innerHTML = `Â§© ${trade.day}: <strong style="color: ${actionColor};">${trade.type === 'Buy' ? '‰π∞ÂÖ•' : 'ÂçñÂá∫'}</strong> ${trade.quantity} ËÇ° ${trade.stockName} @ ${formatCurrency(trade.price)}`;
                ul.appendChild(li);
            });
            aiTradeHistoryDisplay.appendChild(ul);
        }

        // --- Event Listeners for individual stock actions and swipe ---
        function attachActionListeners() {
            stockTableBody.querySelectorAll('button').forEach(button => {
                button.onclick = handleActionClick;
            });
            stockTableBody.querySelectorAll('input[type="number"]').forEach(input => {
                input.addEventListener('touchstart', handleQtyTouchStart, { passive: true });
                input.addEventListener('touchmove', handleQtyTouchMove, { passive: false }); // Prevent default scroll for gesture
                input.addEventListener('touchend', handleQtyTouchEnd, { passive: true });
                input.addEventListener('touchcancel', handleQtyTouchEnd, { passive: true });
            });
        }

        function handleActionClick(e) {
            const button = e.target;
            const index = parseInt(button.getAttribute('data-index'));
            const quantityInput = document.getElementById(`qty-${index}`);
            if (button.classList.contains('buy-button')) {
                const quantity = getQuantity(quantityInput); buyStock(index, quantity, false);
            } else if (button.classList.contains('sell-button')) {
                const quantity = getQuantity(quantityInput); sellStock(index, quantity, false);
            } else if (button.classList.contains('close-button')) {
                closePosition(index);
            }
            quantityInput.value = ''; // Clear input after action
        }

        function handleQtyTouchStart(e) {
            if (e.touches.length === 1) { swipeStartY = e.touches[0].clientY; isSwiping = true; }
            else { isSwiping = false; }
        }
        function handleQtyTouchMove(e) {
            if (!isSwiping || e.touches.length !== 1) return;
            const currentY = e.touches[0].clientY; const deltaY = swipeStartY - currentY;

            let quantityChanged = false;

            if (deltaY > SWIPE_THRESHOLD_PX) { // Swiping up
                const inputElement = e.target; let currentValue = parseInt(inputElement.value) || 0;
                currentValue += SWIPE_INCREMENT_QUANTITY; inputElement.value = currentValue;
                swipeStartY = currentY; // Reset start position for continuous swipe
                quantityChanged = true;
            } else if (deltaY < -SWIPE_THRESHOLD_PX) { // Swiping down
                const inputElement = e.target; let currentValue = parseInt(inputElement.value) || 0;
                currentValue = Math.max(0, currentValue - SWIPE_INCREMENT_QUANTITY); inputElement.value = currentValue;
                swipeStartY = currentY; // Reset start position for continuous swipe
                quantityChanged = true;
            }

            if (quantityChanged) {
                if (navigator.vibrate) { navigator.vibrate(20); } // Haptic feedback
                e.preventDefault(); // Prevent page scrolling
            } else if (Math.abs(deltaY) > 5) { // If there's a small movement but not enough for quantity change, still prevent scroll to make it feel responsive
                e.preventDefault();
            }
        }
        function handleQtyTouchEnd(e) { isSwiping = false; swipeStartY = 0; }

        // --- Bulk Sell Functions ---
        function bulkSell(percentage) {
             if (!gameRunning) return;

             const actionText = percentage === 1 ? "ÂÖ®‰ªì" : percentage === 0.5 ? "Âçä‰ªì" : percentage === 0.25 ? "ÂõõÂàÜ‰πã‰∏Ä‰ªì" : "ÈÉ®ÂàÜ";
             logMessage(`Â∞ùËØï${actionText}ÂçñÂá∫ÊâÄÊúâÊåÅ‰ªìËÇ°Á•®...`, 'info', 'üìâ');
             let stocksSoldCount = 0;

             stocks.forEach((stock, index) => {
                 if (stock.sharesOwned > 0) {
                     const quantityToSell = Math.floor(stock.sharesOwned * percentage);
                     // Ensure quantity is at least 1 if percentage is positive and shares owned > 0
                     const actualQuantityToSell = percentage > 0 ? Math.max(1, quantityToSell) : 0;
                     // Do not sell more than owned
                     const finalQuantityToSell = Math.min(actualQuantityToSell, stock.sharesOwned);

                     if (finalQuantityToSell > 0) {
                          // Use sellStock function, but mark as manual (isAI = false)
                          if (sellStock(index, finalQuantityToSell, false, false)) {
                               stocksSoldCount++;
                          }
                     }
                 }
             });

             if (stocksSoldCount > 0) {
                 logMessage(`ÊàêÂäü${actionText}ÂçñÂá∫ ${stocksSoldCount} Âè™ËÇ°Á•®„ÄÇ`, 'success', '‚úÖ');
             } else {
                 logMessage(`Êú™ËÉΩ${actionText}ÂçñÂá∫‰ªª‰ΩïËÇ°Á•® (ÂèØËÉΩÊ≤°ÊúâÊåÅ‰ªìÊàñËÆ°ÁÆóÊï∞Èáè‰∏çË∂≥1ËÇ°)„ÄÇ`, 'warn', '‚ö†Ô∏è');
             }
             updateUI(); // Update UI after attempting sells
        }

        function sellAllStocks() { bulkSell(1); }
        function sellHalfStocks() { bulkSell(0.5); }
        function sellQuarterStocks() { bulkSell(0.25); }

        // Add a delay for the AI simulation loop
        const SIMULATION_DAY_DELAY_MS = 200; // Milliseconds delay between days

        // New function to run the AI simulation, takes a strategy function as argument
        async function runAiSimulation(strategyLogic, strategyName = "AI Âä©Êâã") {
            if (!gameRunning || currentDay === 0 || currentDay >= MAX_DAYS) {
                if (currentDay === 0) {
                    logMessage("Ëá™Âä®‰∫§Êòì: ÈúÄË¶ÅËá≥Â∞ë‰∏ÄÂ§©ÁöÑÊï∞ÊçÆÊâçËÉΩÂºÄÂßãÊ®°ÊãüÔºåËØ∑ÂÖàËøõÂÖ•‰∏ã‰∏ÄÂ§©„ÄÇ", 'warn');
                } else if (currentDay >= MAX_DAYS) {
                    logMessage("Ëá™Âä®‰∫§Êòì: Ê∏∏ÊàèÂ∑≤ËææÂà∞ÊúÄÂ§ßÂ§©Êï∞ÔºåÊ®°ÊãüÁªìÊùü„ÄÇ", 'warn');
                }
                return;
            }

            activeStrategyName = strategyName; // Update the active strategy name
            logMessage(`${strategyName}: ÂºÄÂßãËá™Âä®Ê®°Êãü...`, 'ai', 'ü§ñ');

            // Disable buttons during simulation
            nextDayButton.disabled = true;
            strategy1Button.disabled = true;
            strategy2Button.disabled = true;
            strategy3Button.disabled = true;
            strategy4Button.disabled = true;
            strategy5Button.disabled = true;
            strategy6Button.disabled = true;
            strategy7Button.disabled = true;
            strategy8Button.disabled = true;

            while (gameRunning && currentDay < MAX_DAYS) {
                // ÂÖàÊé®ËøõÂà∞‰∏ã‰∏ÄÂ§©Âπ∂Êõ¥Êñ∞‰ª∑Ê†º/‰∫ã‰ª∂ÔºåËøôÊ†∑Á≠ñÁï•ÊâçËÉΩÂØπÊúÄÊñ∞Êï∞ÊçÆÂÅöÂá∫ÂèçÂ∫î
                nextDay(); 

                // Âú®Êé®ËøõÂ§©Êï∞ÂêéÊ£ÄÊü•Ê∏∏ÊàèÊòØÂê¶ÁªìÊùüÔºà‰æãÂ¶ÇËææÂà∞ÊúÄÂ§ßÂ§©Êï∞Ôºâ
                if (!gameRunning || currentDay >= MAX_DAYS) {
                    break;
                }
                
                // Áé∞Âú®ÔºåÊâßË°åÈÄâÂÆöÁ≠ñÁï•ÁöÑ‰∫§ÊòìÔºåÂÆÉ‰ª¨Â∞ÜÂü∫‰∫éÂàöÂàöÊõ¥Êñ∞ÁöÑÂΩìÂâçÂ§©Êï∞ÊçÆ
                strategyLogic(); 
                
                // Add delay between days
                await new Promise(resolve => setTimeout(resolve, SIMULATION_DAY_DELAY_MS));
            }

            // Ensure buttons are properly enabled/disabled after simulation
            nextDayButton.disabled = !gameRunning;
            // Re-enable strategy buttons if game is still running and not on final day
            if (gameRunning && currentDay < MAX_DAYS) {
                strategy1Button.disabled = false;
                strategy2Button.disabled = false;
                strategy3Button.disabled = false;
                strategy4Button.disabled = false;
                strategy5Button.disabled = false;
                strategy6Button.disabled = false;
                strategy7Button.disabled = false;
                strategy8Button.disabled = false;
            }
            // If game ended, endGame() already disabled them

            logMessage(`${strategyName}: Ëá™Âä®Ê®°ÊãüÁªìÊùü„ÄÇ`, 'ai', 'üèÅ');
            updateUI(); // Update UI after strategy actions
        }

        // Helper for SMA calculation
        function calculateSMA(stockName, period) {
            const prices = historicalPrices[stockName];
            if (!prices || prices.length < period) return null; // Not enough data
            const relevantPrices = prices.slice(-period);
            const sum = relevantPrices.reduce((a, b) => a + b, 0);
            return sum / period;
        }

        // --- Strategy 1: Ê∂®Ë∑åÂπÖËøΩÂáªËÄÖ (Volatility Chaser) ---
        const VOLATILITY_CHASER_BUY_DROP_PERCENT = 3;   // Ë∑åÂπÖË∂ÖËøá3%‰π∞ÂÖ• (Âéü: 5)
        const VOLATILITY_CHASER_SELL_RISE_PERCENT = 2;  // Ê∂®ÂπÖË∂ÖËøá2%ÂçñÂá∫ (Âéü: 3)
        const VOLATILITY_CHASER_PROFIT_TAKE_PERCENT = 7; // Ê≠¢ÁõàÔºöÁõ∏ËæÉ‰π∞ÂÖ•‰ª∑‰∏äÊ∂®7%ÂçñÂá∫ (Âéü: 10)
        const VOLATILITY_CHASER_STOP_LOSS_PERCENT = 3;  // Ê≠¢ÊçüÔºöÁõ∏ËæÉ‰π∞ÂÖ•‰ª∑‰∏ãË∑å3%ÂçñÂá∫ (Âéü: 5)
        const VOLATILITY_CHASER_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 2; // ÊØèÊ¨°‰∫§ÊòìÊï∞Èáè
        const VOLATILITY_CHASER_MAX_CASH_PER_TRADE_PERCENT = 0.01; // ÊØèÊ¨°‰∫§ÊòìÊäïÂÖ•ÊÄªÁé∞ÈáëÁöÑ1%

        function strategy1Logic() {
            let actionsTaken = 0;
            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const prevPrice = previousPrices[stock.name];
                if (prevPrice === undefined || prevPrice === null || prevPrice === 0) return; // Need previous day data

                const percentageChange = ((currentPrice - prevPrice) / prevPrice) * 100;
                const assumedBuyPrice = aiBoughtPrices[stock.name]; // AI's recorded buy price

                // Sell Logic (Priority: Stop Loss then Profit Take then Daily Rise)
                if (stock.sharesOwned > 0) {
                    // Stop Loss
                    if (assumedBuyPrice && ((assumedBuyPrice - currentPrice) / assumedBuyPrice) * 100 >= VOLATILITY_CHASER_STOP_LOSS_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 1 (ËøΩÂáªËÄÖ): Ê≠¢ÊçüÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (‰∫èÊçü: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üî¥', false);
                        }
                        return; // Done with this stock for selling, prevent further actions
                    }

                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= VOLATILITY_CHASER_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 1 (ËøΩÂáªËÄÖ): Ê≠¢ÁõàÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (Âà©Ê∂¶: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üü¢', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Daily Rise Sell
                    if (percentageChange >= VOLATILITY_CHASER_SELL_RISE_PERCENT) {
                        // Sell a portion, e.g., 50% or fixed quantity, or all if small holding
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned / 2)); // Sell half or default
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 1 (ËøΩÂáªËÄÖ): Ê∂®ÂπÖËææÊ†áÂçñÂá∫ ${quantityToSell} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (+${percentageChange.toFixed(2)}%)`, 'ai', 'üìà', false);
                        }
                    }
                }

                // Buy Logic (Only if not held or if selling action wasn't taken)
                // Ensure we have enough cash to buy at least a small quantity
                if (cash > currentPrice * MIN_PRICE && percentageChange <= -VOLATILITY_CHASER_BUY_DROP_PERCENT) {
                    const maxAffordableQuantity = Math.floor(cash * VOLATILITY_CHASER_MAX_CASH_PER_TRADE_PERCENT / currentPrice);
                    const quantityToBuy = Math.min(VOLATILITY_CHASER_TRADE_QUANTITY, maxAffordableQuantity);

                    if (quantityToBuy > 0) {
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 1 (ËøΩÂáªËÄÖ): Ë∑åÂπÖËææÊ†á‰π∞ÂÖ• ${quantityToBuy} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (${percentageChange.toFixed(2)}%)`, 'ai', 'üìâ', false);
                        }
                    }
                }
            });
            if (actionsTaken > 0) {
                logMessage(`Á≠ñÁï• 1 (ËøΩÂáªËÄÖ): Êú¨ËΩÆÂÆåÊàê ${actionsTaken} Á¨î‰∫§Êòì„ÄÇ`, 'ai', '‚úÖ');
            } else {
                logMessage(`Á≠ñÁï• 1 (ËøΩÂáªËÄÖ): Êú¨ËΩÆÊú™ÊâßË°å‰ªª‰Ωï‰∫§Êòì„ÄÇ`, 'ai', '‚ÑπÔ∏è', false);
            }
            updateUI(); // Update UI after strategy actions
        }

        // --- Strategy 2: ‰ª∑ÂÄºÊäïËµÑËÄÖ (Value Investor) ---
        const VALUE_INVESTOR_CHEAP_PRICE_THRESHOLD = 50; // ‰ª∑Ê†º‰Ωé‰∫é50ÂÖÉËßÜ‰∏∫‰æøÂÆúËÇ°
        const VALUE_INVESTOR_AVG_PRICE_PERCENT_THRESHOLD = 0.8; // ‰ª∑Ê†º‰Ωé‰∫éÂπ≥Âùá‰ª∑Ê†ºÁöÑ80%ËßÜ‰∏∫‰æøÂÆúËÇ°
        const VALUE_INVESTOR_PROFIT_TAKE_PERCENT = 25; // Ê≠¢ÁõàÔºöÁõ∏ËæÉ‰π∞ÂÖ•‰ª∑‰∏äÊ∂®25%ÂçñÂá∫
        const VALUE_INVESTOR_HOLD_QUANTITY_LIMIT = 500; // ÂçïÂè™ËÇ°Á•®ÊåÅ‰ªì‰∏äÈôê
        const VALUE_INVESTOR_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY; // ÊØèÊ¨°‰∫§ÊòìÊï∞Èáè

        function strategy2Logic() {
            let actionsTaken = 0;

            const totalStockPrices = stocks.reduce((sum, stock) => sum + stock.price, 0);
            const averageStockPrice = totalStockPrices / stocks.length;

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Profit Take)
                if (stock.sharesOwned > 0 && assumedBuyPrice) {
                    const profitPercent = ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100;
                    if (profitPercent >= VALUE_INVESTOR_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 2 (‰ª∑ÂÄºÊäïËµÑËÄÖ): Ê≠¢ÁõàÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (Âà©Ê∂¶: ${profitPercent.toFixed(2)}%)`, 'ai', 'üí∞', false);
                        }
                    }
                }

                // Buy Logic (Only if not held or held below limit and price is low)
                if (cash > currentPrice * MIN_PRICE && stock.sharesOwned < VALUE_INVESTOR_HOLD_QUANTITY_LIMIT) {
                    const isCheapByAbsolute = currentPrice < VALUE_INVESTOR_CHEAP_PRICE_THRESHOLD;
                    const isCheapByRelative = currentPrice < averageStockPrice * VALUE_INVESTOR_AVG_PRICE_PERCENT_THRESHOLD;

                    if (isCheapByAbsolute || isCheapByRelative) {
                        const quantityToBuy = VALUE_INVESTOR_TRADE_QUANTITY;
                        if (cash >= currentPrice * quantityToBuy) {
                            if (buyStock(index, quantityToBuy, true, false)) {
                                actionsTaken++;
                                logMessage(`Á≠ñÁï• 2 (‰ª∑ÂÄºÊäïËµÑËÄÖ): ÂèëÁé∞‰ª∑ÂÄºËÇ°‰π∞ÂÖ• ${quantityToBuy} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)}`, 'ai', 'üíé', false);
                            }
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`Á≠ñÁï• 2 (‰ª∑ÂÄºÊäïËµÑËÄÖ): Êú¨ËΩÆÂÆåÊàê ${actionsTaken} Á¨î‰∫§Êòì„ÄÇ`, 'ai', '‚úÖ');
            } else {
                logMessage(`Á≠ñÁï• 2 (‰ª∑ÂÄºÊäïËµÑËÄÖ): Êú¨ËΩÆÊú™ÊâßË°å‰ªª‰Ωï‰∫§Êòì„ÄÇ`, 'ai', '‚ÑπÔ∏è', false);
            }
            updateUI();
        }

        // --- Strategy 3: ‰∫ã‰ª∂ÂìçÂ∫îËÄÖ (Event Responder) ---
        const EVENT_RESPONDER_PROFIT_PERCENT_FOR_POSITIVE_EVENT = 8; // Âõ†ÁßØÊûÅ‰∫ã‰ª∂‰π∞ÂÖ•ÁöÑËÇ°Á•®Ôºå‰∏äÊ∂®8%ÂêéÂçñÂá∫ (Âéü: 10)
        const EVENT_RESPONDER_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 5; // ÊØèÊ¨°‰∫§ÊòìÊï∞ÈáèÊõ¥Â§ß

        function strategy3Logic() {
            let actionsTaken = 0;

            const currentDayEvents = lastMarketEventHappened; // Get all events for the current day
            // Removed: lastMarketEventHappened = []; // Reset for next day

            // Process all events that happened today
            currentDayEvents.forEach(eventData => {
                const event = eventData.event;
                const affectedStock = eventData.stock;
                const index = stocks.indexOf(affectedStock);
                if (index === -1) return; // Stock not found, skip

                // React to Negative Event: Sell immediately
                if (event.type === 'negative') {
                    if (affectedStock.sharesOwned > 0) {
                        if (sellStock(index, affectedStock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 3 (‰∫ã‰ª∂ÂìçÂ∫îËÄÖ): Âõ†„Äê${event.name}„ÄëÊ≠¢ÊçüÂçñÂá∫ ${affectedStock.sharesOwned} ËÇ° ${affectedStock.name}„ÄÇ`, 'ai', event.icon, false);
                        }
                    }
                }
                // React to Positive Event: Buy
                else if (event.type === 'positive') {
                    if (cash > affectedStock.price * MIN_PRICE) {
                        const quantityToBuy = Math.min(EVENT_RESPONDER_TRADE_QUANTITY, Math.floor(cash / affectedStock.price));
                        if (quantityToBuy > 0) {
                            if (buyStock(index, quantityToBuy, true, false)) {
                                actionsTaken++;
                                logMessage(`Á≠ñÁï• 3 (‰∫ã‰ª∂ÂìçÂ∫îËÄÖ): Âõ†„Äê${event.name}„Äë‰π∞ÂÖ• ${quantityToBuy} ËÇ° ${affectedStock.name}„ÄÇ`, 'ai', event.icon, false);
                            }
                        }
                    }
                }
            });

            // Additional logic: Sell existing holdings if they have made significant profit, regardless of current event
            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const assumedBuyPrice = aiBoughtPrices[stock.name];
                if (stock.sharesOwned > 0 && assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= EVENT_RESPONDER_PROFIT_PERCENT_FOR_POSITIVE_EVENT) {
                    if (sellStock(index, stock.sharesOwned, true, false)) {
                        actionsTaken++;
                        logMessage(`Á≠ñÁï• 3 (‰∫ã‰ª∂ÂìçÂ∫îËÄÖ): Ê≠¢ÁõàÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (Âà©Ê∂¶: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üí∞', false);
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`Á≠ñÁï• 3 (‰∫ã‰ª∂ÂìçÂ∫îËÄÖ): Êú¨ËΩÆÂÆåÊàê ${actionsTaken} Á¨î‰∫§Êòì„ÄÇ`, 'ai', '‚úÖ');
            } else {
                logMessage(`Á≠ñÁï• 3 (‰∫ã‰ª∂ÂìçÂ∫îËÄÖ): Êú¨ËΩÆÊú™ÊâßË°å‰ªª‰Ωï‰∫§Êòì„ÄÇ`, 'ai', '‚ÑπÔ∏è', false);
            }
            updateUI();
        }

        // --- Strategy 4: Â∞èÊ≠•Âø´Ë∑ëËÄÖ (Scalper/Day Trader) ---
        const SCALPER_BUY_RISE_MIN_PERCENT = 0.1; // ‰ª∑Ê†º‰∏äÊ∂®0.1%‰ª•‰∏äËÄÉËôë‰π∞ÂÖ• (Âéü: 0.2)
        const SCALPER_BUY_RISE_MAX_PERCENT = 0.5;   // ‰ª∑Ê†º‰∏äÊ∂®Ë∂ÖËøá0.5%‰∏çËøΩÈ´ò‰π∞ÂÖ• (Âéü: 1)
        const SCALPER_PROFIT_TAKE_PERCENT = 0.8;   // Ê≠¢ÁõàÔºöÁõ∏ËæÉ‰π∞ÂÖ•‰ª∑‰∏äÊ∂®0.8%ÂçñÂá∫ (Âéü: 1)
        const SCALPER_DAILY_DROP_SELL_PERCENT = 0.1; // ÂΩìÊó•‰ª∑Ê†º‰∏ãË∑å0.1%ÂàôÂçñÂá∫ÔºàÂç≥‰ΩøÂ∞è‰∫èÔºâ (Âéü: 0.2)
        const SCALPER_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY / 2; // ÊØèÊ¨°‰∫§ÊòìÊï∞ÈáèËæÉÂ∞è

        function strategy4Logic() {
            let actionsTaken = 0;

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const prevPrice = previousPrices[stock.name];
                if (prevPrice === undefined || prevPrice === null || prevPrice === 0) return; // Need previous day data

                const percentageChange = ((currentPrice - prevPrice) / prevPrice) * 100;
                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Priority: Profit Take then Daily Drop Sell)
                if (stock.sharesOwned > 0) {
                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= SCALPER_PROFIT_TAKE_PERCENT) {
                        // Sell a portion, or all if small holding
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned * 0.5));
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 4 (Â∞èÊ≠•Âø´Ë∑ëËÄÖ): Ê≠¢ÁõàÂçñÂá∫ ${quantityToSell} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (Âà©Ê∂¶: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üìà', false);
                        }
                        // Do not return here, as we might buy it again on the same day if conditions are met
                    }
                    // Daily Drop Sell
                    else if (percentageChange <= -SCALPER_DAILY_DROP_SELL_PERCENT) {
                        // Sell a portion, or all if small holding
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned * 0.3));
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 4 (Â∞èÊ≠•Âø´Ë∑ëËÄÖ): Ë∂ãÂäøÂèçËΩ¨ÂçñÂá∫ ${quantityToSell} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (${percentageChange.toFixed(2)}%)`, 'ai', 'üìâ', false);
                        }
                    }
                }

                // Buy Logic (Only if not held or held in small quantity and price is slightly rising/stable)
                if (cash > currentPrice * MIN_PRICE && stock.sharesOwned < SCALPER_TRADE_QUANTITY * 2) { // Only buy if not holding too much
                    if (percentageChange >= SCALPER_BUY_RISE_MIN_PERCENT && percentageChange <= SCALPER_BUY_RISE_MAX_PERCENT) {
                        const quantityToBuy = SCALPER_TRADE_QUANTITY;
                        if (cash >= currentPrice * quantityToBuy) {
                            if (buyStock(index, quantityToBuy, true, false)) {
                                actionsTaken++;
                                logMessage(`Á≠ñÁï• 4 (Â∞èÊ≠•Âø´Ë∑ëËÄÖ): ÂèëÁé∞ÂæÆÊ∂®‰π∞ÂÖ• ${quantityToBuy} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (+${percentageChange.toFixed(2)}%)`, 'ai', '‚ö°', false);
                            }
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`Á≠ñÁï• 4 (Â∞èÊ≠•Âø´Ë∑ëËÄÖ): Êú¨ËΩÆÂÆåÊàê ${actionsTaken} Á¨î‰∫§Êòì„ÄÇ`, 'ai', '‚úÖ');
            } else {
                logMessage(`Á≠ñÁï• 4 (Â∞èÊ≠•Âø´Ë∑ëËÄÖ): Êú¨ËΩÆÊú™ÊâßË°å‰ªª‰Ωï‰∫§Êòì„ÄÇ`, 'ai', '‚ÑπÔ∏è', false);
            }
            updateUI();
        }

        // --- Strategy 5: Â§öÂÖÉÂåñÊäïËµÑËÄÖ (Diversified Investor) ---
        const DIVERSIFIED_INVESTOR_TARGET_STOCKS = 50; // ÁõÆÊ†áÊåÅÊúâ50Âè™‰∏çÂêåËÇ°Á•®
        const DIVERSIFIED_INVESTOR_MAX_SINGLE_STOCK_PERCENT_OF_PORTFOLIO = 0.03; // ÂçïÂè™ËÇ°Á•®Â∏ÇÂÄº‰∏çÂ∫îË∂ÖËøáÊÄªÂ∏ÇÂÄºÁöÑ3%
        const DIVERSIFIED_INVESTOR_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 2; // ÊØèÊ¨°‰∫§ÊòìÊï∞Èáè
        const DIVERSIFIED_INVESTOR_TARGET_PORTFOLIO_PERCENT_OF_NET_WORTH = 0.60; // ÁõÆÊ†áÊåÅ‰ªìÂ∏ÇÂÄºÂç†ÊÄªËµÑ‰∫ßÁöÑÊØî‰æã

        function strategy5Logic() {
            let actionsTaken = 0;

            const portfolioValue = calculatePortfolioValue();
            const netWorth = calculateNetWorth(); // Get current net worth
            const currentHeldStocksCount = stocks.filter(stock => stock.sharesOwned > 0).length;

            // ÂçñÂá∫ÈÄªËæëÔºöÂÜçÂπ≥Ë°°ÔºåÂçñÂá∫Âç†ÊØîËøáÈ´òÁöÑËÇ°Á•®
            stocks.forEach((stock, index) => {
                if (stock.sharesOwned > 0) {
                    const stockCurrentValue = stock.price * stock.sharesOwned;
                    // ÈÅøÂÖçÈô§‰ª•Èõ∂ÔºåÁ°Æ‰øù portfolioValue > 0
                    if (portfolioValue > 0 && (stockCurrentValue / portfolioValue) > DIVERSIFIED_INVESTOR_MAX_SINGLE_STOCK_PERCENT_OF_PORTFOLIO) {
                        // ËÆ°ÁÆóÈúÄË¶ÅÂçñÂá∫ÁöÑÊï∞Èáè‰ª•ËææÂà∞ÁõÆÊ†áÊùÉÈáç
                        const targetValue = portfolioValue * DIVERSIFIED_INVESTOR_MAX_SINGLE_STOCK_PERCENT_OF_PORTFOLIO;
                        const excessShares = stock.sharesOwned - Math.floor(targetValue / stock.price);
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(excessShares / 2)); // ÂçñÂá∫Ë∂ÖÈ¢ùÈÉ®ÂàÜÁöÑ‰∏ÄÂçäÔºåËá≥Â∞ëÈªòËÆ§Êï∞Èáè

                        if (quantityToSell > 0) {
                            if (sellStock(index, quantityToSell, true, false)) {
                                actionsTaken++;
                                logMessage(`Á≠ñÁï• 5 (Â§öÂÖÉÂåñ): ÂÜçÂπ≥Ë°°ÂçñÂá∫ ${quantityToSell} ËÇ° ${stock.name}ÔºåÂç†ÊØîËøáÈ´ò„ÄÇ`, 'ai', '‚öñÔ∏è', false);
                            }
                        }
                    }
                }
            });

            // ‰π∞ÂÖ•ÈÄªËæëÔºöÂ¢ûÂä†ÊåÅ‰ªìÁßçÁ±ªÔºåÊàñÂ¢ûÂä†‰ΩéÂç†ÊØîËÇ°Á•®ÔºåÂêåÊó∂Á°Æ‰øùÊåÅ‰ªìÂ∏ÇÂÄºËææÂà∞ÁõÆÊ†áÊØî‰æã
            const targetPortfolioValue = netWorth * DIVERSIFIED_INVESTOR_TARGET_PORTFOLIO_PERCENT_OF_NET_WORTH;
            const cashToInvest = targetPortfolioValue - portfolioValue;

            // Only buy if current portfolio value is significantly less than target
            if (cashToInvest > 0 && cash > 0) {
                // Filter for stocks not excessively held and ideally at a good price
                const potentialBuyCandidates = stocks.filter(stock => {
                    const stockValue = stock.price * stock.sharesOwned;
                    // Consider buying if not held, or if held but its value is below max single stock percent of portfolio
                    return stock.sharesOwned === 0 || (portfolioValue > 0 && (stockValue / portfolioValue < DIVERSIFIED_INVESTOR_MAX_SINGLE_STOCK_PERCENT_OF_PORTFOLIO * 0.8)); // Buy if well below target single stock allocation
                });

                // Prioritize buying stocks to increase overall portfolio value, but also spread across candidates
                // Distribute cashToInvest among multiple stocks
                let remainingCashToInvest = cashToInvest; // Use cashToInvest as the budget
                let budgetPerStock = Math.min(remainingCashToInvest / Math.max(1, potentialBuyCandidates.length), DIVERSIFIED_INVESTOR_TRADE_QUANTITY * stocks[0].price * 2); // Limit per stock budget

                // Shuffle candidates to ensure diversity in buying order
                potentialBuyCandidates.sort(() => Math.random() - 0.5);

                for (let i = 0; i < potentialBuyCandidates.length && remainingCashToInvest > 0; i++) {
                    const stock = potentialBuyCandidates[i];
                    const index = stocks.indexOf(stock);

                    const maxQuantityAffordable = Math.floor(Math.min(remainingCashToInvest, budgetPerStock) / stock.price); // How much we can afford for this specific stock
                    const quantityToBuy = Math.max(DEFAULT_TRADE_QUANTITY, Math.min(DIVERSIFIED_INVESTOR_TRADE_QUANTITY, maxQuantityAffordable)); // Buy at least default, up to trade quantity, and what's affordable

                    if (quantityToBuy > 0 && cash >= stock.price * quantityToBuy) {
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            remainingCashToInvest -= (stock.price * quantityToBuy * (1 + TRANSACTION_FEE_PERCENT / 100)); // Deduct cost and fee
                            logMessage(`Á≠ñÁï• 5 (Â§öÂÖÉÂåñ): ‰∏∫Áª¥ÊåÅÁõÆÊ†á‰ªì‰Ωç‰π∞ÂÖ• ${quantityToBuy} ËÇ° ${stock.name}„ÄÇ`, 'ai', 'üìà', false);
                        }
                    }
                }
            }

            if (actionsTaken > 0) {
                logMessage(`Á≠ñÁï• 5 (Â§öÂÖÉÂåñ): Êú¨ËΩÆÂÆåÊàê ${actionsTaken} Á¨î‰∫§Êòì„ÄÇ`, 'ai', '‚úÖ');
            } else {
                logMessage(`Á≠ñÁï• 5 (Â§öÂÖÉÂåñ): Êú¨ËΩÆÊú™ÊâßË°å‰ªª‰Ωï‰∫§Êòì„ÄÇ`, 'ai', '‚ÑπÔ∏è', false);
            }
            updateUI();
        }

        // --- Strategy 6: Ë∂ãÂäøËøΩË∏™ËÄÖ (Trend Follower) ---
        function strategy6Logic() {
            let actionsTaken = 0;

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const sma = calculateSMA(stock.name, TREND_FOLLOW_SMA_PERIOD);
                if (sma === null) return; // Not enough data for SMA

                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Priority: Stop Loss, Profit Take, then Trend Reversal)
                if (stock.sharesOwned > 0) {
                    // Stop Loss
                    if (assumedBuyPrice && ((assumedBuyPrice - currentPrice) / assumedBuyPrice) * 100 >= TREND_FOLLOW_STOP_LOSS_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 6 (Ë∂ãÂäøËøΩË∏™ËÄÖ): Ê≠¢ÊçüÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (‰∫èÊçü: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üî¥', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= TREND_FOLLOW_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 6 (Ë∂ãÂäøËøΩË∏™ËÄÖ): Ê≠¢ÁõàÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (Âà©Ê∂¶: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üü¢', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Trend Reversal Sell
                    if (currentPrice < sma * (1 - TREND_FOLLOW_SELL_BELOW_SMA_PERCENT / 100)) {
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned / 2)); // Sell half or default
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 6 (Ë∂ãÂäøËøΩË∏™ËÄÖ): Ë∂ãÂäøÂèçËΩ¨ÂçñÂá∫ ${quantityToSell} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (‰Ωé‰∫éSMA)`, 'ai', 'üìâ', false);
                        }
                    }
                }

                // Buy Logic (Trend Following)
                if (stock.sharesOwned === 0 && cash > currentPrice * MIN_PRICE) { // Only buy if not held and enough cash
                    if (currentPrice > sma * (1 + TREND_FOLLOW_BUY_ABOVE_SMA_PERCENT / 100)) {
                        const quantityToBuy = TREND_FOLLOW_TRADE_QUANTITY;
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 6 (Ë∂ãÂäøËøΩË∏™ËÄÖ): Ë∂ãÂäøÁ°ÆËÆ§‰π∞ÂÖ• ${quantityToBuy} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (È´ò‰∫éSMA)`, 'ai', 'üìà', false);
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`Á≠ñÁï• 6 (Ë∂ãÂäøËøΩË∏™ËÄÖ): Êú¨ËΩÆÂÆåÊàê ${actionsTaken} Á¨î‰∫§Êòì„ÄÇ`, 'ai', '‚úÖ');
            } else {
                logMessage(`Á≠ñÁï• 6 (Ë∂ãÂäøËøΩË∏™ËÄÖ): Êú¨ËΩÆÊú™ÊâßË°å‰ªª‰Ωï‰∫§Êòì„ÄÇ`, 'ai', '‚ÑπÔ∏è', false);
            }
            updateUI();
        }

        // --- Strategy 7: ‰ª∑ÂÄºÂõûÂΩíËÄÖ (Mean Reversion) ---
        function strategy7Logic() {
            let actionsTaken = 0;

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const sma = calculateSMA(stock.name, MEAN_REVERSION_SMA_PERIOD);
                if (sma === null) return; // Not enough data for SMA

                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Priority: Stop Loss, Profit Take, then Reversion Sell)
                if (stock.sharesOwned > 0) {
                    // Stop Loss
                    if (assumedBuyPrice && ((assumedBuyPrice - currentPrice) / assumedBuyPrice) * 100 >= MEAN_REVERSION_STOP_LOSS_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 7 (‰ª∑ÂÄºÂõûÂΩíËÄÖ): Ê≠¢ÊçüÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (‰∫èÊçü: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üî¥', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= MEAN_REVERSION_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 7 (‰ª∑ÂÄºÂõûÂΩíËÄÖ): Ê≠¢ÁõàÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (Âà©Ê∂¶: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üü¢', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Mean Reversion Sell (price significantly above SMA)
                    if (currentPrice > sma * (1 + MEAN_REVERSION_SELL_ABOVE_SMA_PERCENT / 100)) {
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned / 2)); // Sell half or default
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 7 (‰ª∑ÂÄºÂõûÂΩíËÄÖ): ‰ª∑Ê†ºÂÅèÁ¶ªÈ´òÁÇπÂçñÂá∫ ${quantityToSell} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (È´ò‰∫éSMA)`, 'ai', 'üìâ', false);
                        }
                    }
                }

                // Buy Logic (Mean Reversion - price significantly below SMA)
                if (cash > currentPrice * MIN_PRICE && stock.sharesOwned < MEAN_REVERSION_TRADE_QUANTITY * 5) { // Only buy if enough cash and not too much held
                    if (currentPrice < sma * (1 - MEAN_REVERSION_BUY_BELOW_SMA_PERCENT / 100)) {
                        const quantityToBuy = MEAN_REVERSION_TRADE_QUANTITY;
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 7 (‰ª∑ÂÄºÂõûÂΩíËÄÖ): ‰ª∑Ê†ºÂÅèÁ¶ª‰ΩéÁÇπ‰π∞ÂÖ• ${quantityToBuy} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (‰Ωé‰∫éSMA)`, 'ai', 'üìà', false);
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`Á≠ñÁï• 7 (‰ª∑ÂÄºÂõûÂΩíËÄÖ): Êú¨ËΩÆÂÆåÊàê ${actionsTaken} Á¨î‰∫§Êòì„ÄÇ`, 'ai', '‚úÖ');
            } else {
                logMessage(`Á≠ñÁï• 7 (‰ª∑ÂÄºÂõûÂΩíËÄÖ): Êú¨ËΩÆÊú™ÊâßË°å‰ªª‰Ωï‰∫§Êòì„ÄÇ`, 'ai', '‚ÑπÔ∏è', false);
            }
            updateUI();
        }

        // --- Strategy 8: Ë∂ãÂäøËøΩË∏™‰ºòÂåñ (Trend Tracking Optimization) ---
        function strategy8Logic() {
            let actionsTaken = 0;
            logMessage(`Á≠ñÁï• 8 (Ë∂ãÂäøËøΩË∏™‰ºòÂåñ): Ê≠£Âú®ÊâßË°åÊú¨ËΩÆÈÄªËæë... (Â§©Êï∞: ${currentDay})`, 'ai', 'üîç', false); // Always log when logic runs

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const sma = calculateSMA(stock.name, TREND_TRACKING_OPTIMIZED_SMA_PERIOD);
                if (sma === null) return; // Not enough data for SMA

                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Priority: Stop Loss, Profit Take, then Trend Reversal)
                if (stock.sharesOwned > 0) {
                    // Stop Loss
                    if (assumedBuyPrice && ((assumedBuyPrice - currentPrice) / assumedBuyPrice) * 100 >= TREND_TRACKING_OPTIMIZED_STOP_LOSS_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 8 (Ë∂ãÂäøËøΩË∏™‰ºòÂåñ): Ê≠¢ÊçüÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (‰∫èÊçü: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üî¥', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= TREND_TRACKING_OPTIMIZED_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 8 (Ë∂ãÂäøËøΩË∏™‰ºòÂåñ): Ê≠¢ÁõàÂçñÂá∫ ${stock.sharesOwned} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (Âà©Ê∂¶: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'üü¢', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Trend Reversal Sell
                    if (currentPrice < sma * (1 - TREND_TRACKING_OPTIMIZED_SELL_BELOW_SMA_PERCENT / 100)) {
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned / 2)); // Sell half or default
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 8 (Ë∂ãÂäøËøΩË∏™‰ºòÂåñ): Ë∂ãÂäøÂèçËΩ¨ÂçñÂá∫ ${quantityToSell} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (‰Ωé‰∫éSMA)`, 'ai', 'üìâ', false);
                        }
                    }
                }

                // Buy Logic (Trend Following)
                if (stock.sharesOwned === 0 && cash > currentPrice * MIN_PRICE) { // Only buy if not held and enough cash
                    if (currentPrice > sma * (1 + TREND_TRACKING_OPTIMIZED_BUY_ABOVE_SMA_PERCENT / 100)) {
                        const quantityToBuy = TREND_TRACKING_OPTIMIZED_TRADE_QUANTITY;
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            logMessage(`Á≠ñÁï• 8 (Ë∂ãÂäøËøΩË∏™‰ºòÂåñ): Ë∂ãÂäøÁ°ÆËÆ§‰π∞ÂÖ• ${quantityToBuy} ËÇ° ${stock.name} @ ${formatCurrency(currentPrice)} (È´ò‰∫éSMA)`, 'ai', 'üìà', false);
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`Á≠ñÁï• 8 (Ë∂ãÂäøËøΩË∏™‰ºòÂåñ): Êú¨ËΩÆÂÆåÊàê ${actionsTaken} Á¨î‰∫§Êòì„ÄÇ`, 'ai', '‚úÖ');
            } else {
                logMessage(`Á≠ñÁï• 8 (Ë∂ãÂäøËøΩË∏™‰ºòÂåñ): Êú¨ËΩÆÊú™ÊâßË°å‰ªª‰Ωï‰∫§Êòì„ÄÇ`, 'ai', '‚ÑπÔ∏è', false);
            }
            updateUI();
        }

        // --- Initial Call ---
        document.addEventListener('DOMContentLoaded', initializeGame);

        nextDayButton.addEventListener('click', nextDay); // Re-adding the missing event listener

        playAgainButton.addEventListener('click', () => {
            gameOverScreen.style.display = 'none';
            initializeGame();
        });

        // Add listeners for each strategy button
        strategy1Button.addEventListener('click', () => runAiSimulation(strategy1Logic, 'Á≠ñÁï• 1 (Ê∂®Ë∑åÂπÖËøΩÂáªËÄÖ)'));
        strategy2Button.addEventListener('click', () => runAiSimulation(strategy2Logic, 'Á≠ñÁï• 2 (‰ª∑ÂÄºÊäïËµÑËÄÖ)'));
        strategy3Button.addEventListener('click', () => runAiSimulation(strategy3Logic, 'Á≠ñÁï• 3 (‰∫ã‰ª∂ÂìçÂ∫îËÄÖ)'));
        strategy4Button.addEventListener('click', () => runAiSimulation(strategy4Logic, 'Á≠ñÁï• 4 (Â∞èÊ≠•Âø´Ë∑ëËÄÖ)'));
        strategy5Button.addEventListener('click', () => runAiSimulation(strategy5Logic, 'Á≠ñÁï• 5 (Â§öÂÖÉÂåñÊäïËµÑËÄÖ)'));

        // Add listeners for each strategy button
        strategy6Button.addEventListener('click', () => runAiSimulation(strategy6Logic, 'Á≠ñÁï• 6 (Ë∂ãÂäøËøΩË∏™ËÄÖ)'));
        strategy7Button.addEventListener('click', () => runAiSimulation(strategy7Logic, 'Á≠ñÁï• 7 (‰ª∑ÂÄºÂõûÂΩíËÄÖ)'));
        strategy8Button.addEventListener('click', () => runAiSimulation(strategy8Logic, 'Á≠ñÁï• 8 (Ë∂ãÂäøËøΩË∏™‰ºòÂåñ)'));

        // Add listeners for bulk action buttons
        buyAllStocksButton.addEventListener('click', buyAllStocks);
        sellAllButton.addEventListener('click', sellAllStocks);
        sellHalfButton.addEventListener('click', sellHalfStocks);
        sellQuarterButton.addEventListener('click', sellQuarterStocks);

        // --- Manual Bulk Buy Function ---
        function buyAllStocks() {
             if (!gameRunning) return;

             logMessage("Â∞ùËØï‰∏∫ÊâÄÊúâËÇ°Á•®Èõ®Èú≤ÂùáÊ≤æ...", 'info', 'üõí');
             let stocksBoughtCount = 0;

             stocks.forEach((stock, index) => {
                 const quantityToBuy = 100; // Fixed quantity
                 // Check if we can afford at least this quantity
                 if (cash >= stock.price * quantityToBuy) {
                      // Use buyStock function, but mark as manual (isAI = false)
                      if (buyStock(index, quantityToBuy, false, false)) {
                           stocksBoughtCount++;
                      }
                 }
             });

             if (stocksBoughtCount > 0) {
                 logMessage(`ÊàêÂäü‰∏∫ ${stocksBoughtCount} Âè™ËÇ°Á•®‰π∞ÂÖ• 100 ËÇ°„ÄÇ`, 'success', '‚úÖ');
             } else {
                 logMessage("Êú™ËÉΩ‰∏∫‰ªª‰ΩïËÇ°Á•®‰π∞ÂÖ• 100 ËÇ° (ÂèØËÉΩÁé∞Èáë‰∏çË∂≥)„ÄÇ", 'warn', '‚ö†Ô∏è');
             }
             updateUI(); // Update UI after attempting buys
        }

        // --- Custom Stock Addition Function ---
        function addCustomStock() {
            if (!gameRunning) {
                logMessage("Ê∏∏ÊàèÊú™ÂºÄÂßãÔºåÊó†Ê≥ïÊ∑ªÂä†ËÇ°Á•®„ÄÇ", 'warn', '‚ö†Ô∏è');
                return;
            }
            const newStockName = newStockNameInput.value.trim();
            const newStockCode = newStockCodeInput.value.trim();
            const newStockPrice = parseFloat(newStockPriceInput.value);

            if (!newStockName || !newStockCode || isNaN(newStockPrice) || newStockPrice <= 0) {
                logMessage("ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑËÇ°Á•®ÂêçÁß∞„ÄÅ‰ª£Á†ÅÂíåÂàùÂßã‰ª∑Ê†º„ÄÇ", 'error', '‚ùå');
                return;
            }

            // Check for duplicate name or code
            if (stocks.some(s => s.name === newStockName || s.code === newStockCode)) {
                logMessage(`ËÇ°Á•® \'${newStockName}\' (‰ª£Á†Å: ${newStockCode}) Â∑≤Â≠òÂú®ÔºåËØ∑‰ΩøÁî®ÂÖ∂‰ªñÂêçÁß∞Êàñ‰ª£Á†Å„ÄÇ`, 'error', '‚ùå');
                return;
            }

            const newStock = {
                name: newStockName,
                code: newStockCode,
                price: newStockPrice,
                sharesOwned: 0,
                basePrice: newStockPrice,
                growthFactor: (Math.random() * (BASE_PRICE_GROWTH_RATE_MAX - BASE_PRICE_GROWTH_RATE_MIN) + BASE_PRICE_GROWTH_RATE_MIN) / 365,
                previousDayChangePercent: 0
            };

            stocks.push(newStock);
            stocks.sort((a, b) => a.name.localeCompare(b.name)); // Re-sort stocks alphabetically
            historicalPrices[newStock.name] = [newStock.price]; // Initialize historical prices
            previousPrices[newStock.name] = newStock.price; // Initialize previous price for new stock

            logMessage(`ÊàêÂäüÊ∑ªÂä†ËÇ°Á•®: ${newStockName}Ôºå‰ª£Á†Å: ${newStockCode}ÔºåÂàùÂßã‰ª∑Ê†º: ${formatCurrency(newStockPrice)}`, 'success', '‚ûï');
            newStockNameInput.value = ''; // Clear input fields
            newStockCodeInput.value = '';
            newStockPriceInput.value = '';
            updateUI(); // Re-render table with new stock

            // --- Save updated stocks to localStorage ---
            saveCustomStocks();
        }

        // New: Function to save custom stocks to localStorage
        function saveCustomStocks() {
            // Only save the essential properties needed to recreate the stock list
            const stocksToSave = stocks.map(stock => ({
                name: stock.name,
                code: stock.code,
                price: stock.price // Save the current price as the re-initialization price
            }));
            localStorage.setItem('customStocks', JSON.stringify(stocksToSave));
            logMessage("ËÇ°Á•®ÂàóË°®Â∑≤Ëá™Âä®‰øùÂ≠ò„ÄÇ", 'info', 'üíæ', true); // Suppress frequent logging
        }

        // New: Function to clear saved custom stocks from localStorage
        function clearSavedCustomStocks() {
            localStorage.removeItem('customStocks');
            logMessage("Â∑≤Ê∏ÖÈô§ÊâÄÊúâÂ∑≤‰øùÂ≠òÁöÑËá™ÂÆö‰πâËÇ°Á•®„ÄÇ", 'info', 'üóëÔ∏è');
            // After clearing, re-initialize the game to reflect the change
            initializeGame();
        }

    </script>

    <!-- Confetti library for winning effect -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
</body>
</html>