<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åå°”è¡—ä¹‹ç‹¼ - è¡€æˆ˜60å¤©</title>
    <style>
        :root {
            --primary-color: #2962FF;
            --secondary-color: #651FFF; /* AI Button Color */
            --success-color: #00C853;
            --danger-color: #FF3D00;
            --warning-color: #FFAB00;
            --dark-color: #263238;
            --light-color: #ECEFF1;
            --card-bg: #FFFFFF;
            --market-up: #4CAF50;
            --market-down: #F44336;
            --profit-color: #00E676;
            --loss-color: #FF5252;
            --event-color: #7B1FA2; /* For market events */
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 10px;
            margin: 0;
            color: var(--dark-color);
            -webkit-tap-highlight-color: transparent;
            min-height: 100vh;
        }

        #gameContainer {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 1000px;
            box-sizing: border-box;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.3);
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.5rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
            position: relative;
        }

        h1::after {
            content: "";
            display: block;
            width: 40px;
            height: 2px;
            background: var(--primary-color);
            margin: 6px auto 0;
            border-radius: 2px;
        }

        .info-bar {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            background: linear-gradient(to right, var(--primary-color), #3D5AFE);
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-weight: bold;
            font-size: 0.8em;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .info-bar span {
            margin: 5px 10px;
            display: flex;
            align-items: center;
        }

        .info-bar span span {
            margin-left: 5px;
            font-weight: bold;
            color: #FFEB3B;
        }

        #stockTable {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        #stockTable th, #stockTable td {
            padding: 6px 4px;
            text-align: left;
            vertical-align: middle;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            font-size: 0.8em;
        }

        #stockTable th {
            background: linear-gradient(to right, var(--primary-color), #304FFE);
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
            text-align: center;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8em;
            letter-spacing: 0.5px;
        }

        #stockTable tr:not(:first-child) {
            transition: all 0.3s ease;
        }

        #stockTable tr:not(:first-child):hover {
            background-color: rgba(41, 98, 255, 0.05);
            transform: translateX(2px);
        }

        #stockTable tr:nth-child(even) {
            background-color: rgba(0,0,0,0.02);
        }

        .stock-actions input[type="number"] {
            width: 50px;
            padding: 4px;
            margin-right: 4px;
            box-sizing: border-box;
            -moz-appearance: textfield;
            text-align: center;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.8em;
            transition: all 0.2s ease;
        }

        .stock-actions input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(41, 98, 255, 0.2);
        }

        .stock-actions input::-webkit-outer-spin-button,
        .stock-actions input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .stock-actions button {
            padding: 4px 6px;
            cursor: pointer;
            margin-left: 3px;
            border: none;
            border-radius: 3px;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            /* vertical-align: middle; */
            min-width: 24px;
            text-align: center;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .stock-actions button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .stock-actions button:active:not(:disabled) {
            transform: translateY(0);
        }

        /* CN Market Colors */
        .buy-button {
            background: linear-gradient(to right, var(--danger-color), #FF6E40);
        }
        .sell-button {
            background: linear-gradient(to right, var(--success-color), #69F0AE);
        }

        .close-button {
            background: linear-gradient(to right, var(--warning-color), #FFD600);
            color: #333;
        }

        /* Specific style for close button in stock actions to override modal styles */
        td.stock-actions .close-button {
            position: static; /* Override absolute positioning from modal's close-button */
            margin-left: 3px; /* Re-add margin for spacing */
            top: auto; /* Reset top positioning */
            right: auto; /* Reset right positioning */
            font-size: 0.8em; /* Reset font size if necessary */
            min-width: 24px; /* Ensure consistent button size */
        }

        .buy-button:disabled,
        .sell-button:disabled,
        .close-button:disabled {
            background: #B0BEC5;
            cursor: not-allowed;
            color: #ECEFF1;
            box-shadow: none;
        }

        #controls {
            text-align: center;
            margin-bottom: 12px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }

        #nextDayButton, #strategy1Button, #strategy2Button, #strategy3Button, #strategy4Button, #strategy5Button, #strategy6Button, #strategy7Button, #strategy8Button {
            padding: 8px 12px;
            font-size: 0.9em;
            cursor: pointer;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #nextDayButton {
            background: linear-gradient(to right, var(--primary-color), #304FFE);
            box-shadow: 0 4px 8px rgba(41, 98, 255, 0.3);
        }
        #strategy1Button, #strategy2Button, #strategy3Button, #strategy4Button, #strategy5Button, #strategy6Button, #strategy7Button, #strategy8Button {
            background: linear-gradient(to right, var(--secondary-color), #7C4DFF);
            box-shadow: 0 4px 8px rgba(101, 31, 255, 0.3);
        }

        #nextDayButton:hover:not(:disabled),
        #strategy1Button:hover:not(:disabled),
        #strategy2Button:hover:not(:disabled),
        #strategy3Button:hover:not(:disabled),
        #strategy4Button:hover:not(:disabled),
        #strategy5Button:hover:not(:disabled),
        #strategy6Button:hover:not(:disabled),
        #strategy7Button:hover:not(:disabled),
        #strategy8Button:hover:not(:disabled) {
            transform: translateY(-3px);
        }
        #nextDayButton:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(41, 98, 255, 0.4); }
        #strategy1Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy2Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy3Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy4Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy5Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy6Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy7Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }
        #strategy8Button:hover:not(:disabled) { box-shadow: 0 6px 12px rgba(101, 31, 255, 0.4); }

        #nextDayButton:active:not(:disabled),
        #strategy1Button:active:not(:disabled),
        #strategy2Button:active:not(:disabled),
        #strategy3Button:active:not(:disabled),
        #strategy4Button:active:not(:disabled),
        #strategy5Button:active:not(:disabled),
        #strategy6Button:active:not(:disabled),
        #strategy7Button:active:not(:disabled),
        #strategy8Button:active:not(:disabled) {
            transform: translateY(0);
        }

        #nextDayButton:disabled,
        #strategy1Button:disabled,
        #strategy2Button:disabled,
        #strategy3Button:disabled,
        #strategy4Button:disabled,
        #strategy5Button:disabled,
        #strategy6Button:disabled,
        #strategy7Button:disabled,
        #strategy8Button:disabled {
            background: #B0BEC5;
            cursor: not-allowed;
            box-shadow: none;
        }

        #log {
            height: 100px;
            overflow-y: scroll;
            border: 1px solid rgba(0,0,0,0.1);
            padding: 12px;
            background-color: #FAFAFA;
            margin-bottom: 20px;
            font-size: 0.85em;
            line-height: 1.4;
            border-radius: 6px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }

        #log p {
            margin: 3px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        #log p:last-child {
            border-bottom: none;
        }

        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            font-size: 1.2em;
            padding: 30px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
        }

        #gameOverScreen h2 {
            margin-top: 0;
            font-size: 2.5em;
            color: #FFEB3B;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        #gameOverScreen p {
            margin: 15px 0;
            font-size: 1.1em;
        }

        #gameOverScreen button {
            padding: 16px 40px;
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 30px;
            background: linear-gradient(to right, var(--success-color), #00E676);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 200, 83, 0.3);
            text-transform: uppercase;
        }

        #gameOverScreen button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 200, 83, 0.4);
        }

        #gameOverScreen button:active {
            transform: translateY(0);
        }

        .table-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 450px;
            -webkit-overflow-scrolling: touch;
            border-radius: 8px;
            margin-bottom: 20px;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .currency {
            text-align: right;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .number {
            text-align: center;
            font-weight: bold;
        }

        .action-cell {
            white-space: nowrap;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stock-name {
            text-align: left;
            font-weight: 500;
        }

        .price-up { color: var(--market-up); font-weight: bold; }
        .price-down { color: var(--market-down); font-weight: bold; }
        .price-unchanged { color: #9E9E9E; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .pulse { animation: pulse 0.5s ease; }
        .fade-in { animation: fadeIn 0.3s ease forwards; }

        /* Loading Screen styles */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: var(--dark-color);
            font-size: 1.5em;
            font-weight: bold;
        }

        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 480px) {
            #gameContainer { padding: 8px; }
            h1 { font-size: 1.2rem; margin-bottom: 8px; }
            .info-bar { font-size: 0.75em; padding: 6px; }
            #stockTable th, #stockTable td { padding: 4px 2px; font-size: 0.75em; }
            .stock-actions input[type="number"] { width: 40px; padding: 3px; font-size: 0.75em; }
            .stock-actions button { padding: 3px 4px; min-width: 20px; font-size: 0.75em; }
            #nextDayButton, #strategy1Button, #strategy2Button, #strategy3Button, #strategy4Button, #strategy5Button, #strategy6Button, #strategy7Button, #strategy8Button { padding: 6px 10px; font-size: 0.8em; }
            #controls { gap: 6px; }
            #gameOverScreen h2 { font-size: 1.5em; }
            #gameOverScreen p { font-size: 0.9em; }
            #gameOverScreen button { padding: 10px 20px; font-size: 0.9em;}
        }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); border-radius: 3px; }
        ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }

        /* New: Help Icon */
        #helpIcon {
            display: inline-block; /* Make it flow with text */
            vertical-align: middle; /* Align with middle of text */
            margin-left: 5px; /* Add some space from the number */
            background-color: var(--primary-color);
            color: white;
            width: 20px; /* Make it a bit smaller to fit inline */
            height: 20px; /* Make it a bit smaller to fit inline */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8em; /* Adjust font size */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* Smaller shadow */
            z-index: 10; /* Lower z-index as it's not absolutely positioned */
            transition: all 0.2s ease;
        }
        #helpIcon:hover {
            background-color: #304FFE;
            transform: scale(1.1); /* Slightly more prominent hover effect */
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 2% auto;
            }
            #helpIcon {
                top: 10px;
                left: 10px;
                width: 18px;
                height: 18px;
                font-size: 0.7em;
            }
        }

        /* New: Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding-top: 60px;
        }

        .modal-content {
            background-color: var(--light-color);
            margin: 5% auto; /* 5% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            border-radius: 12px;
            width: 90%; /* Could be more responsive */
            max-width: 800px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            animation: fadeIn 0.3s ease-out;
            max-height: 85vh; /* Max height to allow scrolling */
            overflow-y: auto; /* Enable scrolling for content */
        }

        .modal-content h2 {
            color: var(--primary-color);
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .modal-content h3 {
            color: var(--secondary-color);
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 2px solid rgba(101, 31, 255, 0.2);
            padding-bottom: 5px;
        }

        .modal-content p {
            margin-bottom: 8px;
            line-height: 1.6;
        }

        .modal-content ul {
            list-style-type: disc;
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .modal-content li {
            margin-bottom: 5px;
        }

        /* Close Button */
        .close-button {
            color: #aaa;
            position: absolute;
            top: 15px;
            right: 25px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--danger-color);
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="loadingScreen">
        <div class="spinner"></div>
        <p>åå°”è¡—çš„æ›™å…‰æ­£åœ¨å‡èµ·...</p>
    </div>

    <div id="gameContainer" style="display: none;">
        <h1>åå°”è¡—ä¹‹ç‹¼ - è¡€æˆ˜60å¤©</h1>

        <div class="info-bar">
            <span>å¤©æ•°: <span id="currentDay">0</span>/60 <div id="helpIcon" title="æŸ¥çœ‹ç­–ç•¥è¯´æ˜">?</div></span>
            <span>ç°é‡‘: <span id="cashDisplay">Â¥0.00</span></span>
            <span>æŒä»“å¸‚å€¼: <span id="portfolioValueDisplay">Â¥0.00</span></span>
            <span>æ€»èµ„äº§: <span id="netWorthDisplay">Â¥0.00</span></span>
        </div>

        <div id="log">
            <!-- Log messages will appear here -->
        </div>

        <div id="controls">
            <button id="nextDayButton">å¼€å§‹æ¸¸æˆ</button>
            <button id="strategy1Button" disabled title="æ ¹æ®è‚¡ç¥¨æ¯æ—¥ä»·æ ¼çš„æ˜¾è‘—è·Œå¹…ä¹°å…¥ï¼Œåœ¨æ˜¾è‘—æ¶¨å¹…ã€è¾¾åˆ°æ­¢ç›ˆç‚¹æˆ–è§¦åŠæ­¢æŸçº¿æ—¶å–å‡ºã€‚è¿½æ±‚çŸ­æœŸæ³¢åŠ¨æ”¶ç›Šã€‚">ç­–ç•¥ 1: æ¶¨è·Œå¹…è¿½å‡»è€…</button>
            <button id="strategy2Button" disabled title="å¯»æ‰¾ä»·æ ¼ä½äºå¹³å‡æ°´å¹³æˆ–ç»å¯¹å€¼è¾ƒä½çš„&quot;ä¾¿å®œè‚¡&quot;ï¼Œé•¿æœŸæŒæœ‰ã€‚åœ¨ä»·æ ¼å¤§å¹…ä¸Šæ¶¨å¹¶è¾¾åˆ°æ­¢ç›ˆç‚¹æ—¶å–å‡ºã€‚æ³¨é‡é•¿æœŸä»·å€¼æŠ•èµ„ã€‚">ç­–ç•¥ 2: ä»·å€¼æŠ•èµ„è€…</button>
            <button id="strategy3Button" disabled title="ç§¯æå“åº”å¸‚åœºäº‹ä»¶ï¼šè‹¥è‚¡ç¥¨å—æ­£é¢äº‹ä»¶å½±å“åˆ™ä¹°å…¥ï¼›è‹¥å—è´Ÿé¢äº‹ä»¶å½±å“åˆ™å–å‡ºã€‚åŒæ—¶ï¼Œä¹Ÿä¼šå¯¹å·²æŒæœ‰çš„é«˜åˆ©æ¶¦è‚¡ç¥¨è¿›è¡Œæ­¢ç›ˆã€‚">ç­–ç•¥ 3: äº‹ä»¶å“åº”è€…</button>
            <button id="strategy4Button" disabled title="è¿½æ±‚é¢‘ç¹çš„å°é¢äº¤æ˜“ã€‚åœ¨è‚¡ç¥¨å°å¹…ä¸Šæ¶¨æ—¶å¿«é€Ÿä¹°å…¥ï¼Œå¹¶åœ¨è¾¾åˆ°å¾®è–„åˆ©æ¶¦æˆ–å‡ºç°å°å¹…ä¸‹è·Œæ—¶è¿…é€Ÿå–å‡ºã€‚æ³¨é‡æ—¥å†…äº¤æ˜“å’Œèµ„é‡‘å‘¨è½¬ã€‚">ç­–ç•¥ 4: å°æ­¥å¿«è·‘è€…</button>
            <button id="strategy5Button" disabled title="æ—¨åœ¨æ„å»ºå¹¶ç»´æŒä¸€ä¸ªå¹¿æ³›åˆ†æ•£çš„æŠ•èµ„ç»„åˆã€‚åœ¨æŒè‚¡æ•°é‡ä¸è¶³æˆ–æŸäº›è‚¡ç¥¨æƒé‡è¿‡ä½æ—¶ä¹°å…¥ï¼›åœ¨è‚¡ç¥¨å¸‚å€¼å æ¯”è¿‡é«˜æ—¶å–å‡ºä»¥è¿›è¡Œå†å¹³è¡¡ã€‚">ç­–ç•¥ 5: å¤šå…ƒåŒ–æŠ•èµ„è€…</button>
            <button id="strategy6Button" disabled title="è¯†åˆ«å¹¶è·Ÿéšè‚¡ç¥¨çš„çŸ­æœŸä»·æ ¼è¶‹åŠ¿ã€‚å½“ä»·æ ¼æŒç»­ä¸Šæ¶¨æ—¶ä¹°å…¥ï¼ŒæŒç»­ä¸‹è·Œæ—¶å–å‡ºã€‚">ç­–ç•¥ 6: è¶‹åŠ¿è¿½è¸ªè€…</button>
            <button id="strategy7Button" disabled title="åˆ©ç”¨è‚¡ç¥¨ä»·æ ¼å›´ç»•å…¶å†…åœ¨ä»·å€¼æ³¢åŠ¨çš„ç‰¹æ€§ã€‚å½“ä»·æ ¼æ˜¾è‘—ä½äºæˆ–é«˜äºå†…åœ¨ä»·å€¼æ—¶è¿›è¡Œäº¤æ˜“ï¼ŒæœŸå¾…ä»·æ ¼å›å½’ã€‚">ç­–ç•¥ 7: ä»·å€¼å›å½’è€…</button>
            <button id="strategy8Button" disabled title="è¯†åˆ«å¹¶è·Ÿéšè‚¡ç¥¨çš„çŸ­æœŸä»·æ ¼è¶‹åŠ¿ã€‚å½“ä»·æ ¼æŒç»­ä¸Šæ¶¨æ—¶ä¹°å…¥ï¼ŒæŒç»­ä¸‹è·Œæ—¶å–å‡ºã€‚å‚æ•°ï¼šåŸºäº5æ—¥SMAï¼Œä»·æ ¼é«˜äºSMA 0.5%ä¹°å…¥ï¼Œä½äºSMA 0.5%å–å‡ºï¼Œæ­¢ç›ˆ15%ï¼Œæ­¢æŸ5%ã€‚">ç­–ç•¥ 8: è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–</button>
            <button id="buyAllStocksButton">é›¨éœ²å‡æ²¾</button>
            <button id="sellAllButton">å…¨ä»“å–å‡ºæ‰€æœ‰</button>
            <button id="sellHalfButton">åŠä»“å–å‡ºæ‰€æœ‰</button>
            <button id="sellQuarterButton">å››åˆ†ä¹‹ä¸€ä»“å–å‡ºæ‰€æœ‰</button>
            <div style="margin-top: 15px; border-top: 1px dashed rgba(0,0,0,0.1); padding-top: 15px; width: 100%;">
                <h3 style="color: var(--secondary-color); font-size: 1em; margin-bottom: 10px; text-align: center;">è‡ªè¡Œæ·»åŠ è‚¡ç¥¨</h3>
                <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 8px;">
                    <input type="text" id="newStockName" placeholder="è‚¡ç¥¨åç§°" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 120px;">
                    <input type="text" id="newStockCode" placeholder="è‚¡ç¥¨ä»£ç " maxlength="6" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 80px;">
                    <input type="number" id="newStockPrice" placeholder="åˆå§‹ä»·æ ¼" min="0.01" step="0.01" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100px;">
                    <button id="addStockButton" style="background: linear-gradient(to right, #4CAF50, #8BC34A); color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;">æ·»åŠ è‚¡ç¥¨</button>
                    <button id="clearSavedStocksButton" style="background: linear-gradient(to right, #FF9800, #FFB74D); color: white; padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.3s ease;">æ¸…ç©ºè‚¡ç¥¨</button>
                </div>
            </div>
        </div>

        <div class="table-container">
            <table id="stockTable">
                <thead>
                    <tr>
                        <th>åç§°</th>
                        <th>ä»£ç </th>
                        <th>ä»·æ ¼</th>
                        <th>æ¶¨è·Œå¹…</th>
                        <th>æŒä»“</th>
                        <th>å¸‚å€¼</th>
                        <th>æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody id="stockTableBody">
                    <!-- Stock rows generated by JS -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- New: Strategy Help Modal -->
    <div id="strategyHelpModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>è‡ªåŠ¨äº¤æ˜“ç­–ç•¥è¯´æ˜</h2>
            <div id="strategyExplanationContent">
                <!-- Strategy explanations will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <div id="gameOverScreen">
        <h2>æŠ•èµ„è¯¦æƒ…</h2>
        <p>æ‚¨å·²ç»å®Œæˆäº†60å¤©çš„äº¤æ˜“æŒ‘æˆ˜</p>
        <p>åˆå§‹èµ„é‡‘: Â¥<span id="initialCapitalResult"></span></p>
        <p>æœ€ç»ˆèµ„äº§: Â¥<span id="finalNetWorthResult"></span></p>
        <p>ç›ˆäº: <span id="profitLossResult"></span></p>
        <p>ç›ˆäºæ¯”ä¾‹: <span id="profitLossPercentageResult"></span> <!-- New: Profit/Loss Percentage -->
        <p>æ‚¨çš„ç§°å·: <span id="playerTitle"></span></p>
        <p>é‡‡ç”¨ç­–ç•¥: <span id="usedStrategyDisplay"></span> <!-- New: Used Strategy Display -->
        <p>å·…å³°èµ„äº§: Â¥<span id="peakNetWorthDisplay"></span></p> <!-- New: Peak Net Worth Display -->
        <p>æœ€ä½èµ„äº§: Â¥<span id="troughNetWorthDisplay"></span></p> <!-- New: Trough Net Worth Display -->
        <div id="aiTradeHistoryDisplay" style="margin-top: 20px; text-align: left; max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px;"></div>
        <p>æ€»äº¤æ˜“æ¬¡æ•°: <span style="color:#FFEB3B;" id="finalTotalTrades"></span></p>
        <p>æ€»äº¤æ˜“ç¨è´¹: <span style="color:#FFEB3B;" id="finalTotalFees"></span></p>
        <button id="playAgainButton">å†æˆ˜ä¸€è½®</button>
    </div>

    <script>
        // --- Game Configuration ---
        const INITIAL_CASH = 5000000;
        const NUM_STOCKS = 0; // Changed from 10 to 0
        const MAX_DAYS = 60; // Changed from 180 to 60
        const MIN_PRICE = 0.01;
        const MAX_PRICE_FLUCTUATION_PERCENT = 8;
        const INITIAL_PRICE_MIN = 10;
        const INITIAL_PRICE_MAX = 150;
        const DEFAULT_TRADE_QUANTITY = 100;
        const SWIPE_INCREMENT_QUANTITY = 100;
        const SWIPE_THRESHOLD_PX = 30;

        // New: Transaction Fee
        const TRANSACTION_FEE_PERCENT = 0.015; // ä¸‡åˆ†ä¹‹ä¸‰ = 0.015%

        // New: Market Simulation Parameters
        const MOMENTUM_FACTOR = 0.3; // How much previous day's change influences current day's change (0 to 1)
        const BASE_PRICE_GROWTH_RATE_MIN = -0.05; // Annual growth rate min for base price (-5%)
        const BASE_PRICE_GROWTH_RATE_MAX = 0.10; // Annual growth rate max for base price (10%)

        // AI Configuration (Strategic AI)
        const AI_BUY_MIN = 3; // Min stocks AI tries to buy per click
        const AI_BUY_MAX = 8; // Max stocks AI tries to buy per click

        // Market Event Configuration
        const POSITIVE_EVENT_EFFECT_MIN = 15; // +15%
        const POSITIVE_EVENT_EFFECT_MAX = 40; // +40%
        const NEGATIVE_EVENT_EFFECT_MIN = 15; // -15%
        const NEGATIVE_EVENT_EFFECT_MAX = 40; // -40%

        // Strategy 6: è¶‹åŠ¿è¿½è¸ªè€… (Trend Follower)
        const TREND_FOLLOW_SMA_PERIOD = 5; // SMA Period for trend detection
        const TREND_FOLLOW_BUY_ABOVE_SMA_PERCENT = 0.5; // Buy if price is 0.5% above SMA
        const TREND_FOLLOW_SELL_BELOW_SMA_PERCENT = 0.5; // Sell if price is 0.5% below SMA
        const TREND_FOLLOW_PROFIT_TAKE_PERCENT = 10; // Profit target
        const TREND_FOLLOW_STOP_LOSS_PERCENT = 5; // Stop loss
        const TREND_FOLLOW_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 2; // Trade quantity

        // Strategy 7: ä»·å€¼å›å½’è€… (Mean Reversion)
        const MEAN_REVERSION_SMA_PERIOD = 10; // Longer SMA Period for intrinsic value
        const MEAN_REVERSION_BUY_BELOW_SMA_PERCENT = 5; // Buy if price is 5% below SMA
        const MEAN_REVERSION_SELL_ABOVE_SMA_PERCENT = 5; // Sell if price is 5% above SMA
        const MEAN_REVERSION_PROFIT_TAKE_PERCENT = 25; // Profit target
        const MEAN_REVERSION_STOP_LOSS_PERCENT = 5; // Stop loss
        const MEAN_REVERSION_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY; // Trade quantity

        // Strategy 8: è¶‹åŠ¿è¿½è¸ªä¼˜åŒ– (Trend Tracking Optimization)
        const TREND_TRACKING_OPTIMIZED_SMA_PERIOD = 5; // SMA Period for trend detection
        const TREND_TRACKING_OPTIMIZED_BUY_ABOVE_SMA_PERCENT = 0.5; // Buy if price is 0.5% above SMA
        const TREND_TRACKING_OPTIMIZED_SELL_BELOW_SMA_PERCENT = 0.5; // Sell if price is 0.5% below SMA
        const TREND_TRACKING_OPTIMIZED_PROFIT_TAKE_PERCENT = 15; // Profit target
        const TREND_TRACKING_OPTIMIZED_STOP_LOSS_PERCENT = 5; // Stop loss
        const TREND_TRACKING_OPTIMIZED_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 2; // Trade quantity

        // New: Per-stock event probability
        const PER_STOCK_EVENT_PROBABILITY = 0.03; // Each stock has a 3% chance of an event each day

        const marketEvents = [
            // Positive Events
            { type: 'positive', name: 'çªç ´æ€§æŠ€æœ¯å…¬å¸ƒ', description: 'æ–°ææ–™ç§‘æŠ€å–å¾—é‡å¤§è¿›å±•!', effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN, icon: 'ğŸš€' },
            { type: 'positive', name: 'è´¢æŠ¥è¶…é¢„æœŸ', description: 'å…¬å¸ç›ˆåˆ©è¿œè¶…å¸‚åœºé¢„æœŸ!', effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN, icon: 'ğŸ’°' },
            { type: 'positive', name: 'é‡å¤§åˆ©å¥½æ”¿ç­–', description: 'æ”¿åºœé¢å¸ƒè¡Œä¸šæ‰¶æŒæ”¿ç­–ï¼Œå¸‚åœºä¿¡å¿ƒå¤§å¢!', effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN, icon: 'ğŸŒŸ' },
            { type: 'positive', name: 'æ”¶è´­å…¼å¹¶æˆåŠŸ', description: 'å¼ºå¼ºè”åˆï¼Œå¸¦æ¥ååŒæ•ˆåº”!', effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN, icon: 'ğŸ¤' },
            // Negative Events
            { type: 'negative', name: 'çªå‘è´Ÿé¢æ–°é—»', description: 'å…¬å¸äº§å“è¢«æ›å®‰å…¨éšæ‚£!', effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN), icon: 'ğŸš¨' },
            { type: 'negative', name: 'æ ¸å¿ƒé«˜ç®¡ç¦»èŒ', description: 'å…¬å¸é¦–å¸­æ‰§è¡Œå®˜çªç„¶è¾èŒ!', effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN), icon: 'ğŸ‘”' },
            { type: 'negative', name: 'è¡Œä¸šæ”¿ç­–æ”¶ç´§', description: 'ç›‘ç®¡éƒ¨é—¨åŠ å¼ºç®¡æ§ï¼Œå¸‚åœºå‰æ™¯ä¸æ˜!', effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN), icon: 'ğŸš¨' },
            { type: 'negative', name: 'äº§å“å¬å›äº‹ä»¶', description: 'å¤§è§„æ¨¡äº§å“å¬å›ï¼Œæ¶ˆè´¹è€…ä¿¡å¿ƒå—æŒ«!', effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN), icon: 'âš¡' },
        ];

        // Dynamically add more positive events
        const additionalPositiveEvents = [
            { name: 'æ–°è¯ç ”å‘æˆåŠŸ', description: 'çªç ´æ€§è¯ç‰©è·æ‰¹ä¸Šå¸‚ï¼' },
            { name: 'å…¨çƒè®¢å•æ¿€å¢', description: 'å›½é™…å¸‚åœºéœ€æ±‚æ—ºç››ï¼Œå‡ºå£é¢åˆ›æ–°é«˜ï¼' },
            { name: 'æˆ˜ç•¥åˆä½œè¾¾æˆ', description: 'ä¸è¡Œä¸šå·¨å¤´ç­¾ç½²é•¿æœŸåˆä½œåè®®ï¼' },
            { name: 'æ”¿åºœè¡¥è´´åŠ ç ', description: 'è·å¾—å·¨é¢è´¢æ”¿æ”¯æŒï¼Œå‘å±•å‰æ™¯å¹¿é˜”ï¼' },
            { name: 'æŠ€æœ¯ä¸“åˆ©è·æ‰¹', description: 'æ ¸å¿ƒæŠ€æœ¯å¾—åˆ°æ³•å¾‹ä¿æŠ¤ï¼Œç«äº‰ä¼˜åŠ¿å‡¸æ˜¾ï¼' },
            { name: 'æ¶ˆè´¹è€…ä¿¡å¿ƒæŒ‡æ•°å¤§æ¶¨', description: 'å¸‚åœºæƒ…ç»ªé«˜æ¶¨ï¼Œæ¶ˆè´¹æ„æ„¿å¼ºçƒˆï¼' },
            { name: 'å›½é™…è¯„çº§ä¸Šè°ƒ', description: 'ä¿¡ç”¨ç­‰çº§æå‡ï¼Œèèµ„æˆæœ¬é™ä½ï¼' },
            { name: 'ç»¿è‰²èƒ½æºæ–°æ”¿', description: 'æ–°èƒ½æºäº§ä¸šè¿æ¥æ”¿ç­–åˆ©å¥½ï¼Œå‘å±•æé€Ÿï¼' },
            { name: 'æ—…æ¸¸ä¸šå¤è‹', description: 'è¾¹å¢ƒå¼€æ”¾ï¼Œæ—…æ¸¸æ¶ˆè´¹äº•å–·å¼å¢é•¿ï¼' },
            { name: 'å¤§å®—å•†å“ä»·æ ¼ä¸Šæ¶¨', description: 'åŸææ–™ä»·æ ¼æ”€å‡ï¼Œç›¸å…³äº§ä¸šåˆ©æ¶¦ä¸°åšï¼' },
            { name: 'æ–°å…´å¸‚åœºæœºé‡', description: 'åœ¨æ–°å…´ç»æµä½“å–å¾—é‡å¤§ä¸šåŠ¡çªç ´ï¼' },
            { name: 'ç ”å‘æŠ•å…¥å›æŠ¥ä¸°åš', description: 'é«˜æŠ•å…¥ç ”å‘é¡¹ç›®ç»“å‡ºç¡•æœï¼' },
            { name: 'å“ç‰Œå½±å“åŠ›æå‡', description: 'å…¬å¸å“ç‰ŒçŸ¥ååº¦å¤§å¹…æå‡ï¼Œå¸‚åœºå æœ‰ç‡æ‰©å¤§ï¼' },
            { name: 'æµ·å¤–å¸‚åœºæ‰©å¼ ', description: 'æˆåŠŸæ‰“å…¥å›½é™…å¸‚åœºï¼Œä¸šåŠ¡ç‰ˆå›¾æŒç»­æ‰©å¤§ï¼' },
            { name: 'ç®¡ç†å±‚å˜åŠ¨åˆ©å¥½', description: 'æ–°ç®¡ç†å±‚ä¸Šä»»ï¼Œå¸‚åœºé¢„æœŸå‘å¥½ï¼' },
            { name: 'ä¾›åº”é“¾ä¼˜åŒ–', description: 'ä¾›åº”é“¾æ•ˆç‡å¤§å¹…æå‡ï¼Œæˆæœ¬æ˜¾è‘—ä¸‹é™ï¼' },
            { name: 'æ•°å­—åŒ–è½¬å‹æˆåŠŸ', description: 'æ•°å­—åŒ–æˆ˜ç•¥åˆæ˜¾æˆæ•ˆï¼Œè¿è¥æ•ˆç‡æé«˜ï¼' },
            { name: 'ç¯ä¿æŠ€æœ¯çªç ´', description: 'ç ”å‘å‡ºåˆ›æ–°ç¯ä¿æŠ€æœ¯ï¼Œå¸‚åœºå‰æ™¯å¹¿é˜”ï¼' },
            { name: 'è¡Œä¸šåä¼šåŠ›æŒº', description: 'è·å¾—è¡Œä¸šåä¼šå¤§åŠ›æ”¯æŒï¼Œå¸‚åœºåœ°ä½ç¨³å›ºï¼' },
            { name: 'æ¶ˆè´¹å‡çº§è¶‹åŠ¿', description: 'æŠ“ä½æ¶ˆè´¹å‡çº§æœºé‡ï¼Œé«˜ç«¯äº§å“é”€é‡å¤§å¢ï¼' },
            { name: 'æˆåŠŸå‘è¡Œæ–°å€º', description: 'ä½æˆæœ¬èèµ„ï¼Œèµ„é‡‘é“¾å……è¶³ï¼' },
            { name: 'è‚¡ç¥¨å›è´­è®¡åˆ’', description: 'å…¬å¸å®£å¸ƒå¤§è§„æ¨¡è‚¡ç¥¨å›è´­ï¼ŒææŒ¯è‚¡ä»·ï¼' },
            { name: 'åˆ†çº¢æ–¹æ¡ˆè¶…é¢„æœŸ', description: 'é«˜é¢åˆ†çº¢æ–¹æ¡ˆå‡ºç‚‰ï¼Œå¸å¼•æŠ•èµ„è€…ï¼' },
            { name: 'æˆ˜ç•¥æŠ•èµ„è€…å…¥è‚¡', description: 'çŸ¥åæŠ•èµ„æœºæ„æˆ˜ç•¥å…¥è‚¡ï¼Œå‰æ™¯çœ‹å¥½ï¼' },
            { name: 'äº§å“è·å¾—å›½é™…å¤§å¥–', description: 'äº§å“è´¨é‡å’Œåˆ›æ–°è·å¾—å›½é™…è®¤å¯ï¼' },
            { name: 'äº§èƒ½æ‰©å¼ æˆåŠŸ', description: 'æ–°å¢äº§èƒ½é¡ºåˆ©æŠ•äº§ï¼Œè¥æ”¶å¢é•¿å¯æœŸï¼' },
            { name: 'å°±ä¸šæ•°æ®å¼ºåŠ²', description: 'å…¨å›½å°±ä¸šç‡æŒç»­å¢é•¿ï¼Œç»æµæ´»åŠ›å¢å¼ºï¼' },
            { name: 'å‡ºå£æ•°æ®è¶…é¢„æœŸ', description: 'å‡ºå£è´¸æ˜“é¢å¤§å¹…å¢é•¿ï¼Œå›½é™…ç«äº‰åŠ›æå‡ï¼' },
            { name: 'åˆ›æ–°äº§å“å‘å¸ƒ', description: 'å‘å¸ƒåˆ’æ—¶ä»£æ–°äº§å“ï¼Œå¼•å‘å¸‚åœºè½°åŠ¨ï¼' },
            { name: 'ç¨æ”¶ä¼˜æƒ æ”¿ç­–', description: 'æ”¿åºœå‡ºå°ç¨æ”¶å‡å…æ”¿ç­–ï¼Œé™ä½ä¼ä¸šè´Ÿæ‹…ï¼' },
            { name: 'åŸºç¡€è®¾æ–½å»ºè®¾åŠ é€Ÿ', description: 'å›½å®¶å¤§åŠ›æŠ•èµ„åŸºå»ºï¼Œç›¸å…³äº§ä¸šå—ç›Šï¼' },
            { name: 'åŸææ–™ä»·æ ¼å›è½', description: 'æˆæœ¬å‹åŠ›ç¼“è§£ï¼Œä¼ä¸šåˆ©æ¶¦ç©ºé—´æ‰©å¤§ï¼' },
            { name: 'äººå£çº¢åˆ©æ˜¾ç°', description: 'åŠ³åŠ¨åŠ›å¸‚åœºä¾›éœ€æ”¹å–„ï¼Œç”Ÿäº§æ•ˆç‡æé«˜ï¼' },
            { name: 'åŸå¸‚åŒ–è¿›ç¨‹åŠ å¿«', description: 'åŸå¸‚äººå£å¢é•¿ï¼Œå¸¦åŠ¨æˆ¿åœ°äº§åŠç›¸å…³äº§ä¸šï¼' },
            { name: 'åŒ»ç–—æ”¹é©åˆ©å¥½', description: 'åŒ»ç–—å¥åº·é¢†åŸŸè¿æ¥æ”¿ç­–æ˜¥å¤©ï¼Œå¸‚åœºæ½œåŠ›å·¨å¤§ï¼' },
            { name: 'æ•™è‚²æŠ•å…¥å¢åŠ ', description: 'æ”¿åºœåŠ å¤§æ•™è‚²æ”¯å‡ºï¼Œæ•™è‚²è¡Œä¸šå‘å±•è¿…çŒ›ï¼' },
            { name: 'å†œä¸šç§‘æŠ€çªç ´', description: 'å†œä¸šç”Ÿäº§æ•ˆç‡æå‡ï¼Œé£Ÿå“å®‰å…¨å¾—åˆ°ä¿éšœï¼' },
            { name: 'æ–‡åŒ–äº§ä¸šç¹è£', description: 'æ–‡åŒ–å¨±ä¹æ¶ˆè´¹éœ€æ±‚æ—ºç››ï¼Œè¡Œä¸šå‘å±•åŠ¿å¤´è‰¯å¥½ï¼' },
            { name: 'ä½“è‚²äº§ä¸šå‘å±•', description: 'ä½“è‚²èµ›äº‹å’Œå¥èº«æ´»åŠ¨å…´èµ·ï¼Œç›¸å…³äº§ä¸šè“¬å‹ƒå‘å±•ï¼' },
            { name: 'å›½é˜²å†›å·¥è®¢å•', description: 'è·å¾—å¤§é‡å›½é˜²å†›å·¥è®¢å•ï¼Œä¸šç»©ç¨³å®šå¢é•¿ï¼' },
            { name: 'åŒºå—é“¾æŠ€æœ¯åº”ç”¨', description: 'åŒºå—é“¾æŠ€æœ¯åœ¨é‡‘èé¢†åŸŸå–å¾—çªç ´æ€§åº”ç”¨ï¼' },
            { name: 'äººå·¥æ™ºèƒ½æ™®åŠ', description: 'AIæŠ€æœ¯æ¸—é€å„è¡Œå„ä¸šï¼Œæé«˜ç”Ÿäº§åŠ›ï¼' },
            { name: 'å¤§æ•°æ®åˆ†æè¿›å±•', description: 'å¤§æ•°æ®åº”ç”¨å¸®åŠ©ä¼ä¸šç²¾å‡†å†³ç­–ï¼' },
            { name: 'äº‘è®¡ç®—æœåŠ¡å¢é•¿', description: 'äº‘æœåŠ¡éœ€æ±‚çˆ†å‘ï¼Œç›¸å…³å…¬å¸è¥æ”¶å¤§å¢ï¼' },
            { name: 'ç‰©è”ç½‘è®¾å¤‡æ™®åŠ', description: 'æ™ºèƒ½è®¾å¤‡è¿æ¥æ•°é‡æ¿€å¢ï¼Œä¸‡ç‰©äº’è”æ—¶ä»£åŠ é€Ÿï¼' },
            { name: '5Gç½‘ç»œè¦†ç›–', description: '5GåŸºç«™å»ºè®¾åŠ é€Ÿï¼Œé€šä¿¡è¡Œä¸šè¿æ¥å‘å±•é«˜å³°ï¼' },
            { name: 'è‡ªåŠ¨é©¾é©¶æŠ€æœ¯æˆç†Ÿ', description: 'è‡ªåŠ¨é©¾é©¶å•†ä¸šåŒ–è½åœ°ï¼Œæ±½è½¦è¡Œä¸šè¿æ¥å˜é©ï¼' },
            { name: 'å¤ªç©ºæ¢ç´¢æ–°è¿›å±•', description: 'å•†ä¸šèˆªå¤©å…¬å¸å–å¾—é‡å¤§çªç ´ï¼Œå¼•çˆ†å¸‚åœºï¼' },
            { name: 'åŸºå› ç¼–è¾‘æŠ€æœ¯åˆ›æ–°', description: 'åŸºå› ç–—æ³•å–å¾—é‡å¤§è¿›å±•ï¼Œæ²»æ„ˆç–‘éš¾æ‚ç—‡ï¼' },
            { name: 'æ–°å‹ç”µæ± ç ”å‘æˆåŠŸ', description: 'èƒ½é‡å¯†åº¦å¤§å¢ï¼Œç”µåŠ¨æ±½è½¦ç»­èˆªé‡Œç¨‹ç¿»å€ï¼' }
        ];

        // Dynamically add more negative events
        const additionalNegativeEvents = [
            { name: 'çªå‘ç–«æƒ…çˆ†å‘', description: 'æ–°å‹ç—…æ¯’è”“å»¶ï¼Œç»æµæ´»åŠ¨åœæ»ï¼' },
            { name: 'å›½é™…è´¸æ˜“æ‘©æ“¦åŠ å‰§', description: 'å…³ç¨å£å’å‡é«˜ï¼Œå…¨çƒä¾›åº”é“¾å—é˜»ï¼' },
            { name: 'è‡ªç„¶ç¾å®³ä¾µè¢­', description: 'ä¸¥é‡æ´ªæ¶ç¾å®³ï¼Œå†œäº§å“ä¾›åº”ç´§å¼ ï¼' },
            { name: 'åŸææ–™ä»·æ ¼æš´æ¶¨', description: 'å…³é”®åŸææ–™ä¾›åº”çŸ­ç¼ºï¼Œç”Ÿäº§æˆæœ¬é£™å‡ï¼' },
            { name: 'ç›‘ç®¡å®¡æŸ¥æ”¶ç´§', description: 'åå„æ–­è°ƒæŸ¥å¯åŠ¨ï¼Œç§‘æŠ€å·¨å¤´é¢ä¸´æŒ‘æˆ˜ï¼' },
            { name: 'å€ºåŠ¡å±æœºè”“å»¶', description: 'å¤šå›½æ”¿åºœå€ºåŠ¡é«˜ä¼ï¼Œå¼•å‘å¸‚åœºæ‹…å¿§ï¼' },
            { name: 'é“¶è¡Œä½“ç³»é£é™©', description: 'éƒ¨åˆ†é“¶è¡Œå‡ºç°æµåŠ¨æ€§é—®é¢˜ï¼Œé‡‘èå¸‚åœºåŠ¨è¡ï¼' },
            { name: 'åŠ³èµ„çº çº·å‡çº§', description: 'å¤§è§„æ¨¡å·¥äººç½¢å·¥ï¼Œç”Ÿäº§å—åˆ°ä¸¥é‡å½±å“ï¼' },
            { name: 'ç«äº‰å¯¹æ‰‹åè¶…', description: 'æ ¸å¿ƒäº§å“è¢«ç«äº‰å¯¹æ‰‹è¶…è¶Šï¼Œå¸‚åœºä»½é¢æµå¤±ï¼' },
            { name: 'é«˜ç®¡è´ªè…ä¸‘é—»', description: 'å…¬å¸é«˜å±‚æ›å‡ºè´ªè…ä¸‘é—»ï¼Œä¿¡èª‰å—æŸï¼' },
            { name: 'äº§å“è´¨é‡é—®é¢˜', description: 'å¤§è§„æ¨¡äº§å“å¬å›ï¼Œæ¶ˆè´¹è€…æŠ•è¯‰æ¿€å¢ï¼' },
            { name: 'ç½‘ç»œå®‰å…¨æ¼æ´', description: 'å…¬å¸ç³»ç»Ÿé­å—é»‘å®¢æ”»å‡»ï¼Œæ•°æ®æ³„éœ²ï¼' },
            { name: 'è¯‰è®¼ç¼ èº«', description: 'é¢ä¸´å·¨é¢è¯‰è®¼èµ”å¿ï¼Œè´¢åŠ¡å‹åŠ›å·¨å¤§ï¼' },
            { name: 'å®è§‚ç»æµä¸‹è¡Œ', description: 'ç»æµå¢é•¿æ”¾ç¼“ï¼Œé€šè´§è†¨èƒ€å‹åŠ›åŠ å¤§ï¼' },
            { name: 'æˆ¿åœ°äº§å¸‚åœºé‡å†·', description: 'æ¥¼å¸‚æˆäº¤é‡å¤§å¹…ä¸‹æ»‘ï¼Œç›¸å…³äº§ä¸šå—å†²å‡»ï¼' },
            { name: 'èƒ½æºä»·æ ¼æ³¢åŠ¨', description: 'å›½é™…æ²¹ä»·å‰§çƒˆæ³¢åŠ¨ï¼Œèƒ½æºä¼ä¸šé¢ä¸´æŒ‘æˆ˜ï¼' },
            { name: 'åœ°ç¼˜æ”¿æ²»ç´§å¼ ', description: 'åœ°åŒºå†²çªå‡çº§ï¼Œå…¨çƒé¿é™©æƒ…ç»ªå‡æ¸©ï¼' },
            { name: 'æŠ€æœ¯ç“¶é¢ˆå‡ºç°', description: 'æ ¸å¿ƒæŠ€æœ¯ç ”å‘é­é‡ç“¶é¢ˆï¼Œäº§å“å‡çº§å—é˜»ï¼' },
            { name: 'äººæ‰æµå¤±ä¸¥é‡', description: 'å…³é”®æŠ€æœ¯äººæ‰å¤§é‡æµå¤±ï¼Œå½±å“åˆ›æ–°èƒ½åŠ›ï¼' },
            { name: 'å¸‚åœºéœ€æ±‚èç¼©', description: 'æ¶ˆè´¹è€…è´­ä¹°åŠ›ä¸‹é™ï¼Œäº§å“é”€é‡é”å‡ï¼' },
            { name: 'ä¾›åº”é“¾ä¸­æ–­', description: 'å›½é™…ç‰©æµå—é˜»ï¼ŒåŸææ–™å’Œäº§å“è¿è¾“å›°éš¾ï¼' },
            { name: 'ç«äº‰åŠ å‰§', description: 'å¸‚åœºç«äº‰ç™½çƒ­åŒ–ï¼Œåˆ©æ¶¦ç©ºé—´è¢«å‹ç¼©ï¼' },
            { name: 'æ–°å…´æŠ€æœ¯å†²å‡»', description: 'é¢ è¦†æ€§æŠ€æœ¯å‡ºç°ï¼Œä¼ ç»Ÿäº§ä¸šé¢ä¸´æ·˜æ±°ï¼' },
            { name: 'ç¯å¢ƒæ³•è§„æ”¶ç´§', description: 'ç¯ä¿æ ‡å‡†æé«˜ï¼Œä¼ä¸šåˆè§„æˆæœ¬å¢åŠ ï¼' },
            { name: 'æ¶ˆè´¹è€…æŠµåˆ¶', description: 'å› è´Ÿé¢äº‹ä»¶å¼•å‘æ¶ˆè´¹è€…æŠµåˆ¶ï¼Œå“ç‰Œå½¢è±¡å—æŸï¼' },
            { name: 'è¯„çº§æœºæ„ä¸‹è°ƒè¯„çº§', description: 'ä¿¡ç”¨è¯„çº§è¢«ä¸‹è°ƒï¼Œèèµ„éš¾åº¦å¢åŠ ï¼' },
            { name: 'ä¸šç»©é¢„è­¦å‘å¸ƒ', description: 'å…¬å¸å‘å¸ƒç›ˆåˆ©é¢„è­¦ï¼Œè‚¡ä»·æš´è·Œï¼' },
            { name: 'é€€å¸‚é£é™©è­¦å‘Š', description: 'å…¬å¸é¢ä¸´é€€å¸‚é£é™©ï¼ŒæŠ•èµ„è€…ææ…Œï¼' },
            { name: 'å›½é™…åˆ¶è£å‡çº§', description: 'å—åˆ°å›½é™…åˆ¶è£ï¼Œæµ·å¤–ä¸šåŠ¡å—é˜»ï¼' },
            { name: 'è´§å¸è´¬å€¼', description: 'æœ¬å¸å¤§å¹…è´¬å€¼ï¼Œè¿›å£æˆæœ¬å¢åŠ ï¼' },
            { name: 'åˆ©ç‡ä¸Šè°ƒ', description: 'å¤®è¡ŒåŠ æ¯ï¼Œä¼ä¸šèèµ„æˆæœ¬ä¸Šå‡ï¼' },
            { name: 'é€šè´§ç´§ç¼©æ‹…å¿§', description: 'ç‰©ä»·æŒç»­ä¸‹è·Œï¼Œæ¶ˆè´¹æ¬²æœ›å‡å¼±ï¼' },
            { name: 'ç½¢å·¥æ½®è”“å»¶', description: 'å¤šä¸ªè¡Œä¸šçˆ†å‘ç½¢å·¥ï¼Œç¤¾ä¼šç§©åºå—åˆ°å½±å“ï¼' },
            { name: 'ç ´äº§æ½®æ¶Œç°', 'description': 'å¤§é‡ä¸­å°ä¼ä¸šå€’é—­ï¼Œå¤±ä¸šç‡é£™å‡ï¼' },
            { name: 'é»‘å¤©é¹…äº‹ä»¶', description: 'ä¸å¯é¢„æµ‹çš„çªå‘äº‹ä»¶ï¼Œå¸‚åœºå‰§çƒˆåŠ¨è¡ï¼' },
            { name: 'èƒ½æºå±æœº', description: 'å…¨çƒèƒ½æºä¾›åº”ç´§å¼ ï¼Œå·¥ä¸šç”Ÿäº§å—é™ï¼' },
            { name: 'ç²®é£Ÿå±æœº', description: 'å†œä½œç‰©æ­‰æ”¶ï¼Œé£Ÿå“ä»·æ ¼æš´æ¶¨ï¼' },
            { name: 'æ°´èµ„æºçŸ­ç¼º', description: 'å¹²æ—±å¯¼è‡´æ°´èµ„æºåŒ®ä¹ï¼Œå†œä¸šç”Ÿäº§å—æŒ«ï¼' },
            { name: 'ç¤¾ä¼šåŠ¨è¡', description: 'ç¤¾ä¼šçŸ›ç›¾æ¿€åŒ–ï¼Œå½±å“ç»æµç¨³å®šï¼' },
            { name: 'æŠ€æœ¯æ³„éœ²', description: 'æ ¸å¿ƒæŠ€æœ¯è¢«ç›—å–ï¼Œç«äº‰ä¼˜åŠ¿ä¸§å¤±ï¼' },
            { name: 'æ•°æ®éšç§ä¸‘é—»', description: 'ç”¨æˆ·æ•°æ®æ³„éœ²ï¼Œå¼•å‘å¹¿æ³›å…³æ³¨å’Œä¿¡ä»»å±æœºï¼' },
            { name: 'AIä¼¦ç†é—®é¢˜', description: 'äººå·¥æ™ºèƒ½å‘å±•é­é‡ä¼¦ç†æŒ‘æˆ˜ï¼Œå¼•å‘äº‰è®®ï¼' },
            { name: 'å¤ªç©ºåƒåœ¾å¨èƒ', description: 'å¤ªç©ºç¢ç‰‡é—®é¢˜æ—¥ç›Šä¸¥é‡ï¼Œå¨èƒå«æ˜Ÿå®‰å…¨ï¼' },
            { name: 'ç”Ÿç‰©æ­¦å™¨å¨èƒ', description: 'ç”Ÿç‰©ç§‘æŠ€æ»¥ç”¨ï¼Œå¼•å‘å…¨çƒææ…Œï¼' },
            { name: 'æç«¯å¤©æ°”äº‹ä»¶', description: 'å…¨çƒæ°”å€™å˜æš–ï¼Œæç«¯å¤©æ°”é¢‘å‘ï¼Œå½±å“ç”Ÿäº§ç”Ÿæ´»ï¼' },
            { name: 'å…»è€é‡‘å±æœº', description: 'äººå£è€é¾„åŒ–åŠ å‰§ï¼Œå…»è€é‡‘ä½“ç³»é¢ä¸´å´©æºƒï¼' },
            { name: 'æ•™è‚²ç³»ç»Ÿå´©æºƒ', description: 'æ•™è‚²èµ„æºåˆ†é…ä¸å‡ï¼Œç¤¾ä¼šå…¬å¹³æ€§å—æŸï¼' },
            { name: 'åŒ»ç–—ç³»ç»Ÿè¶…è½½', description: 'å…¬å…±å«ç”Ÿäº‹ä»¶å¯¼è‡´åŒ»ç–—èµ„æºè€—å°½ï¼' },
            { name: 'åŸå¸‚åŸºç¡€è®¾æ–½è€åŒ–', description: 'åŸå¸‚ç®¡ç½‘ç ´è£‚ï¼Œäº¤é€šæ‹¥å µï¼Œå½±å“æ°‘ç”Ÿï¼' },
            { name: 'æ ¸æ³„æ¼äº‹æ•…', description: 'æ ¸ç”µç«™å‘ç”Ÿæ³„æ¼ï¼Œé€ æˆç¯å¢ƒç¾éš¾ï¼' }
        ];

        additionalPositiveEvents.forEach(event => {
            marketEvents.push({
                type: 'positive',
                name: event.name,
                description: event.description,
                effect: (stock) => Math.random() * (POSITIVE_EVENT_EFFECT_MAX - POSITIVE_EVENT_EFFECT_MIN) + POSITIVE_EVENT_EFFECT_MIN,
                icon: 'âœ¨' // Generic positive icon
            });
        });

        additionalNegativeEvents.forEach(event => {
            marketEvents.push({
                type: 'negative',
                name: event.name,
                description: event.description,
                effect: (stock) => -(Math.random() * (NEGATIVE_EVENT_EFFECT_MAX - NEGATIVE_EVENT_EFFECT_MIN) + NEGATIVE_EVENT_EFFECT_MIN),
                icon: 'ğŸ‘' // Generic negative icon
            });
        });

        // --- Game State Variables ---
        let cash = 0;
        let currentDay = 0;
        let stocks = [];
        let gameRunning = false;
        let swipeStartY = 0;
        let isSwiping = false;
        let previousPrices = {}; // Stores previous day's closing prices for fluctuation comparison
        let aiBoughtPrices = {}; // AI's internal tracking of assumed buy price for owned stocks (for its strategy)
        let aiTradeHistory = []; // Stores AI trade records
        let lastMarketEventHappened = []; // Stores the actual market event that happened on the current day, initialized as array
        let totalTrades = 0; // New: Total number of buy/sell transactions
        let totalFees = 0;   // New: Total transaction fees paid
        let activeStrategyName = "æ‰‹åŠ¨æ“ä½œ"; // New: Default to manual operation
        let peakNetWorth = INITIAL_CASH; // New: Initialize at declaration
        let troughNetWorth = INITIAL_CASH; // New: Initialize at declaration

        // Store historical prices for SMA calculations for each stock
        let historicalPrices = {}; // { stockName: [price1, price2, ...]}

        // --- UI Elements ---
        const loadingScreen = document.getElementById('loadingScreen');
        const gameContainer = document.getElementById('gameContainer');
        const currentDayDisplay = document.getElementById('currentDay');
        const cashDisplay = document.getElementById('cashDisplay');
        const portfolioValueDisplay = document.getElementById('portfolioValueDisplay');
        const netWorthDisplay = document.getElementById('netWorthDisplay');
        const stockTableBody = document.getElementById('stockTableBody');
        const nextDayButton = document.getElementById('nextDayButton');
        const logElement = document.getElementById('log');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const initialCapitalResult = document.getElementById('initialCapitalResult');
        const finalNetWorthResult = document.getElementById('finalNetWorthResult');
        const profitLossResult = document.getElementById('profitLossResult');
        const playerTitleDisplay = document.getElementById('playerTitle');
        const playAgainButton = document.getElementById('playAgainButton');
        const aiTradeHistoryDisplay = document.getElementById('aiTradeHistoryDisplay');
        const buyAllStocksButton = document.getElementById('buyAllStocksButton');
        const sellAllButton = document.getElementById('sellAllButton');
        const sellHalfButton = document.getElementById('sellHalfButton');
        const sellQuarterButton = document.getElementById('sellQuarterButton');
        const profitLossPercentageResult = document.getElementById('profitLossPercentageResult');
        const usedStrategyDisplay = document.getElementById('usedStrategyDisplay');
        const peakNetWorthDisplay = document.getElementById('peakNetWorthDisplay');
        const troughNetWorthDisplay = document.getElementById('troughNetWorthDisplay');

        // New: Custom Stock Addition Elements
        const newStockNameInput = document.getElementById('newStockName');
        const newStockCodeInput = document.getElementById('newStockCode');
        const newStockPriceInput = document.getElementById('newStockPrice');
        const addStockButton = document.getElementById('addStockButton');

        // New: Help Modal UI Elements
        const helpIcon = document.getElementById('helpIcon');
        const strategyHelpModal = document.getElementById('strategyHelpModal');
        const closeButton = document.querySelector('#strategyHelpModal .close-button');
        const strategyExplanationContent = document.getElementById('strategyExplanationContent');

        // --- Helper Functions ---
        function formatCurrency(amount) {
            return 'Â¥' + amount.toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&');
        }

        function logMessage(message, type = 'info', icon = '', doNotLog = false) {
            // Option to suppress logging for performance during rapid events (e.g., AI sim)
            if (doNotLog) return;

            const p = document.createElement('p');
            p.className = 'fade-in';
            let formattedMessage = '';

            switch(type) {
                case 'error': p.style.color = 'var(--danger-color)'; p.style.fontWeight = 'bold'; formattedMessage = `${icon || 'âŒ'} ${message}`; break;
                case 'success': p.style.color = 'var(--success-color)'; formattedMessage = `${icon || 'âœ…'} ${message}`; break;
                case 'warn': p.style.color = 'var(--warning-color)'; formattedMessage = `${icon || 'âš ï¸'} ${message}`; break;
                case 'profit': p.style.color = 'var(--profit-color)'; p.style.fontWeight = 'bold'; formattedMessage = `${icon || 'ğŸ’°'} ${message}`; break;
                case 'loss': p.style.color = 'var(--loss-color)'; p.style.fontWeight = 'bold'; formattedMessage = `${icon || 'ğŸ“‰'} ${message}`; break;
                case 'event': p.style.color = 'var(--event-color)'; p.style.fontWeight = 'bold'; formattedMessage = `${icon} ã€å¸‚åœºäº‹ä»¶ã€‘ ${message}`; break;
                case 'ai': p.style.color = 'var(--secondary-color)'; formattedMessage = `${icon || 'ğŸ¤–'} ${message}`; break;
                default: p.style.color = 'var(--dark-color)'; formattedMessage = `${icon} ${message}`;
            }
            p.innerHTML = formattedMessage;

            logElement.appendChild(p);
            logElement.scrollTop = logElement.scrollHeight;

            // Limit log size to prevent performance issues on long games
            if (logElement.children.length > 50) {
                logElement.removeChild(logElement.children[0]);
            }
        }

        function generateRandomName() {
            const prefixes = ["ç§‘", "ç‘", "å", "åš", "åˆ›", "ä¿¡", "é€š", "å®‰", "æµ·", "äº‘", "æ™º", "å…‰", "é‡‘", "é“¶", "é¾™", "è™"];
            const middles = ["è¾¾", "è®¯", "è¿œ", "èŠ¯", "ç››", "æ³°", "åº·", "å¾®", "æ–°", "æ’", "æ™®", "æ­£", "å¯Œ", "è´µ", "è´¢", "æº"];
            const suffixes = ["ç§‘æŠ€", "è‚¡ä»½", "ä¿¡æ¯", "æ™ºèƒ½", "é›†å›¢", "ç”Ÿç‰©", "èƒ½æº", "ææ–™", "ç½‘ç»œ", "ç”µå­", "é‡‘è", "æŠ•èµ„", "èµ„æœ¬", "è¯åˆ¸", "åŸºé‡‘", "é“¶è¡Œ"];
            const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
            const middle = middles[Math.floor(Math.random() * middles.length)];
            const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
            const num = Math.floor(Math.random() * 900) + 100;
            if (Math.random() > 0.4) return `${prefix}${middle}${suffix}(${num})`;
            else return `${prefix}${suffix}(${num})`;
        }

        function calculatePortfolioValue() {
            return stocks.reduce((total, stock) => total + (stock.price * stock.sharesOwned), 0);
        }

        function calculateNetWorth() {
            return cash + calculatePortfolioValue();
        }

        // --- UI Update Functions ---
        function updateUI() {
            currentDayDisplay.textContent = currentDay;
            cashDisplay.textContent = formatCurrency(cash);
            const portfolioValue = calculatePortfolioValue();
            portfolioValueDisplay.textContent = formatCurrency(portfolioValue);
            const netWorth = cash + portfolioValue;
            netWorthDisplay.textContent = formatCurrency(netWorth);

            // Update peak and trough net worth
            if (netWorth > peakNetWorth) {
                peakNetWorth = netWorth;
            }
            if (netWorth < troughNetWorth) {
                troughNetWorth = netWorth;
            }

            if (currentDay > 0) {
                // Add a slight animation for money updates
                cashDisplay.classList.add('pulse');
                portfolioValueDisplay.classList.add('pulse');
                netWorthDisplay.classList.add('pulse');
                setTimeout(() => {
                    cashDisplay.classList.remove('pulse');
                    portfolioValueDisplay.classList.remove('pulse');
                    netWorthDisplay.classList.remove('pulse');
                }, 500);
            }
            // Ensure action buttons are always up-to-date after UI updates
            renderStockTable();
        }

        function renderStockTable() {
            stockTableBody.innerHTML = '';
            stocks.forEach((stock, index) => {
                const row = stockTableBody.insertRow();
                const sharesOwned = stock.sharesOwned;
                const currentPrice = stock.price;
                const prevPrice = previousPrices[stock.name];

                let priceChangeClass = 'price-unchanged';
                if (previousPrices[stock.name] !== undefined && previousPrices[stock.name] !== null) {
                    if (currentPrice > previousPrices[stock.name]) priceChangeClass = 'price-up';
                    else if (currentPrice < previousPrices[stock.name]) priceChangeClass = 'price-down';
                }

                // Extract stock name and code (prioritize new 'code' property)
                let stockName = stock.name;
                let stockCode = '';

                if (stock.code) {
                    stockCode = stock.code;
                } else {
                    const nameMatch = stock.name.match(/^(.*)\((\d+)\)$/);
                    if (nameMatch) {
                        stockName = nameMatch[1];
                        stockCode = nameMatch[2];
                    }
                }

                // Format stock code to be 6 digits with leading zeros
                const formattedStockCode = stockCode ? stockCode.padStart(6, '0') : '';

                // Calculate percentage change
                let percentageChange = 0;
                if (prevPrice !== undefined && prevPrice !== null && prevPrice > 0) {
                    percentageChange = ((currentPrice - prevPrice) / prevPrice) * 100;
                }

                // Format percentage change and determine class
                const formattedPercentageChange = percentageChange.toFixed(2) + '%';
                let percentageChangeClass = 'price-unchanged';
                if (percentageChange > 0) percentageChangeClass = 'price-up';
                else if (percentageChange < 0) percentageChangeClass = 'price-down';

                row.innerHTML = `
                    <td class="stock-name">${stockName}</td>
                    <td class="number">${formattedStockCode}</td>
                    <td class="currency ${priceChangeClass}">${formatCurrency(currentPrice)}</td>
                    <td class="currency ${percentageChangeClass}">${formattedPercentageChange}</td>
                    <td class="number">${sharesOwned}</td>
                    <td class="currency">${formatCurrency(currentPrice * sharesOwned)}</td>
                    <td class="stock-actions action-cell">
                        <input type="number" id="qty-${index}" inputmode="numeric" pattern="[0-9]*" placeholder="æ•°é‡(${DEFAULT_TRADE_QUANTITY})" title="å‘ä¸Šæ»‘åŠ¨å¢åŠ ${SWIPE_INCREMENT_QUANTITY}è‚¡">
                        <button class="buy-button" data-index="${index}" ${cash < currentPrice * MIN_PRICE ? 'disabled' : ''} title="ä¹°å…¥è‚¡ç¥¨">ä¹°</button>
                        <button class="sell-button" data-index="${index}" ${sharesOwned === 0 ? 'disabled' : ''} title="å–å‡ºè‚¡ç¥¨">å–</button>
                        <button class="close-button" data-index="${index}" ${sharesOwned === 0 ? 'disabled' : ''} title="å–å‡ºå…¨éƒ¨ ${sharesOwned} è‚¡">å¹³ä»“</button>
                    </td>
                `;
                // Update previous price AFTER rendering the row with comparison class
                // REMOVED: previousPrices[stock.name] = currentPrice;
            });
            attachActionListeners();
        }

        // --- Game Logic Functions ---
        function initializeGame() {
            logElement.innerHTML = ''; // Clear previous log
            logMessage("ğŸ‰ æ¬¢è¿æ¥åˆ°åå°”è¡—ä¹‹ç‹¼æ¨¡æ‹Ÿå™¨ v4ï¼", 'info');
            logMessage("ğŸ’¡ æç¤ºï¼šæ‚¨å·²å°†åˆå§‹è‚¡ç¥¨æ•°é‡è®¾ç½®ä¸º0ã€‚è¯·ä½¿ç”¨ä¸‹æ–¹'è‡ªè¡Œæ·»åŠ è‚¡ç¥¨'åŠŸèƒ½æ·»åŠ æ‚¨çš„è‚¡ç¥¨ã€‚", 'info'); // Updated log message

            cash = INITIAL_CASH;
            currentDay = 0;
            stocks = [];
            gameRunning = false;
            previousPrices = {};
            aiBoughtPrices = {}; // Reset AI's internal buy prices
            aiTradeHistory = []; // Reset AI trade history
            lastMarketEventHappened = []; // Reset for a new game, ensure it's an array
            totalTrades = 0; // Reset total trades
            totalFees = 0;   // Reset total fees
            activeStrategyName = "æ‰‹åŠ¨æ“ä½œ"; // Reset for a new game
            peakNetWorth = INITIAL_CASH; // Reset for a new game
            troughNetWorth = INITIAL_CASH; // Reset for a new game

            gameOverScreen.style.display = 'none';
            nextDayButton.disabled = false;
            // Disable all strategy buttons until game starts
            strategy1Button.disabled = true;
            strategy2Button.disabled = true;
            strategy3Button.disabled = true;
            strategy4Button.disabled = true;
            strategy5Button.disabled = true;
            strategy6Button.disabled = true;
            strategy7Button.disabled = true;
            strategy8Button.disabled = true;

            buyAllStocksButton.disabled = true; // Disable until game starts
            sellAllButton.disabled = true; // Disable until game starts
            sellHalfButton.disabled = true; // Disable until game starts
            sellQuarterButton.disabled = true; // Disable until game starts
            nextDayButton.textContent = "å¼€å§‹æ¸¸æˆ";

            // --- Load stocks from localStorage ---
            const savedStocks = localStorage.getItem('customStocks');
            if (savedStocks) {
                try {
                    const parsedStocks = JSON.parse(savedStocks);
                    // Ensure loaded stocks have all necessary properties for new game
                    stocks = parsedStocks.map(s => ({
                        name: s.name,
                        code: s.code,
                        price: s.price,
                        sharesOwned: 0, // Always reset sharesOwned for a new game
                        basePrice: s.price, // Reset basePrice to loaded price
                        growthFactor: (Math.random() * (BASE_PRICE_GROWTH_RATE_MAX - BASE_PRICE_GROWTH_RATE_MIN) + BASE_PRICE_GROWTH_RATE_MIN) / 365,
                        previousDayChangePercent: 0
                    }));
                    // Initialize historical prices for loaded stocks
                    stocks.forEach(s => {
                        historicalPrices[s.name] = [s.price];
                        previousPrices[s.name] = s.price; // Also set initial previous price for consistency
                    });
                    logMessage(`å·²åŠ è½½ ${stocks.length} åªè‡ªå®šä¹‰è‚¡ç¥¨ã€‚`, 'info', 'ğŸ“');
                } catch (e) {
                    console.error("Failed to parse saved stocks from localStorage:", e);
                    logMessage("åŠ è½½ä¿å­˜çš„è‚¡ç¥¨å¤±è´¥ï¼Œå°†ä»é›¶å¼€å§‹ã€‚", 'error', 'âŒ');
                }
            } else {
                // If no saved stocks and NUM_STOCKS is 0, proceed with empty array
                // const names = new Set();
                // while (names.size < NUM_STOCKS) { names.add(generateRandomName()); }
                // names.forEach(name => {
                //     const initialPrice = parseFloat((Math.random() * (INITIAL_PRICE_MAX - INITIAL_PRICE_MIN) + INITIAL_PRICE_MIN).toFixed(2));
                //     const nameMatch = name.match(/^(.*)\((\d+)\)$/);
                //     const stockCode = nameMatch ? nameMatch[2] : '000000';
                //     stocks.push({
                //         name: name,
                //         code: stockCode,
                //         price: initialPrice,
                //         sharesOwned: 0,
                //         basePrice: initialPrice,
                //         growthFactor: growthFactor,
                //         previousDayChangePercent: 0
                //     });
                //     historicalPrices[name] = [initialPrice];
                // });
                // stocks.sort((a, b) => a.name.localeCompare(b.name));
                logMessage("æœªæ‰¾åˆ°å·²ä¿å­˜çš„è‡ªå®šä¹‰è‚¡ç¥¨ã€‚è¯·æ·»åŠ æ‚¨çš„è‚¡ç¥¨ã€‚", 'info', 'â•');
            }
            
            // Original code related to NUM_STOCKS for initial stock generation is commented out
            // since NUM_STOCKS is now 0 and user wants to add their own.
            // const names = new Set();
            // while (names.size < NUM_STOCKS) { names.add(generateRandomName()); }

            // Define growthFactor once for all stocks (can be applied to loaded/new stocks)
            // This block should be after stocks are potentially loaded/generated
            const growthFactor = (Math.random() * (BASE_PRICE_GROWTH_RATE_MAX - BASE_PRICE_GROWTH_RATE_MIN) + BASE_PRICE_GROWTH_RATE_MIN) / 365;
            stocks.forEach(stock => {
                // Assign a new random growth factor for each loaded stock too
                // to ensure dynamic price changes over time, not just initial price.
                stock.growthFactor = (Math.random() * (BASE_PRICE_GROWTH_RATE_MAX - BASE_PRICE_GROWTH_RATE_MIN) + BASE_PRICE_GROWTH_RATE_MIN) / 365;
            });
            stocks.sort((a, b) => a.name.localeCompare(b.name)); // Ensure sorted after load/addition

            updateUI();
            // No need to render stock table here, as updateUI calls it

            // Hide loading screen and show game container after a short delay
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                gameContainer.style.display = 'block';
            }, 1000); // Simulate loading time
        }

        function updateStockPrices() {
            let marketTrend = 0;
            stocks.forEach(stock => {
                // Store the *current* price before calculating the new one for comparison
                previousPrices[stock.name] = stock.price;
                historicalPrices[stock.name].push(stock.price);
                // Keep historical data array size limited to prevent excessive memory usage
                if (historicalPrices[stock.name].length > Math.max(TREND_FOLLOW_SMA_PERIOD, MEAN_REVERSION_SMA_PERIOD) * 2) {
                    historicalPrices[stock.name].shift(); // Remove oldest price
                }

                // 1. Base Price Growth (Intrinsic Value)
                stock.basePrice = stock.basePrice * (1 + stock.growthFactor); // Compound daily

                // 2. Momentum Effect
                const momentumEffect = stock.previousDayChangePercent * MOMENTUM_FACTOR;

                // 3. Random Fluctuation (reduced impact)
                const randomFluctuation = (Math.random() * 2 - 1) * (MAX_PRICE_FLUCTUATION_PERCENT / 2); // Reduced random fluctuation

                // Combine effects
                const totalChangePercent = momentumEffect + randomFluctuation;
                let newPrice = stock.price * (1 + totalChangePercent / 100);

                // Add marketTrend from previous logic (sum up for overall market trend)
                marketTrend += totalChangePercent;

                // Small chance of significant random volatility (unrelated to market events) - keep this for realism
                if (Math.random() < 0.03) {
                    const bigJumpPercent = (Math.random() * 2 - 1) * MAX_PRICE_FLUCTUATION_PERCENT * 2.5;
                    newPrice = stock.price * (1 + bigJumpPercent / 100);
                    logMessage(`ã€å¸‚åœºæ³¢åŠ¨ã€‘${stock.name} ä»·æ ¼å‰§çƒˆæ³¢åŠ¨!`, 'warn', 'ğŸ’¥', true); // Suppress logging for performance
                }

                newPrice = Math.max(MIN_PRICE, parseFloat(newPrice.toFixed(2)));

                // Calculate actual percentage change for next day's momentum
                stock.previousDayChangePercent = ((newPrice - stock.price) / stock.price) * 100;

                stock.price = newPrice;
            });

            // Apply overall market trend based on average daily stock changes - keep this
            // Use stocks.length instead of NUM_STOCKS to account for user-added stocks
            if (stocks.length > 0) { // Prevent division by zero if no stocks at all
                marketTrend = marketTrend / stocks.length * 0.3; // Less impactful overall trend
                if (Math.abs(marketTrend) > 0.5) {
                    stocks.forEach(stock => {
                        stock.price = Math.max(MIN_PRICE, parseFloat((stock.price * (1 + marketTrend / 100)).toFixed(2)));
                    });
                    logMessage(marketTrend > 0 ? `ğŸ“ˆ å¸‚åœºæ•´ä½“å‘ˆç°ä¸Šæ¶¨è¶‹åŠ¿` : `ğŸ“‰ å¸‚åœºæ•´ä½“å‘ˆç°ä¸‹è·Œè¶‹åŠ¿`, marketTrend > 0 ? 'profit' : 'loss', '', true); // Suppress logging for performance
                }
            } else {
                // If there are no stocks, the marketTrend calculation doesn't make sense
                // and should be skipped to prevent NaN/Infinity.
                marketTrend = 0; // Reset or ensure it's not used in a way that causes issues
            }

            // --- Introduce Market Events (Per Stock) ---
            const currentDayEvents = []; // Collect all events that happen on this day
            if (currentDay > 10) { // Only after some initial days
                stocks.forEach(stock => {
                    if (Math.random() < PER_STOCK_EVENT_PROBABILITY) {
                        const event = marketEvents[Math.floor(Math.random() * marketEvents.length)];
                        const priceEffect = event.effect(stock); // Calculate percentage change for this specific stock

                        stock.price = Math.max(MIN_PRICE, parseFloat((stock.price * (1 + priceEffect / 100)).toFixed(2)));
                        
                        currentDayEvents.push({ event: event, stock: stock, priceEffect: priceEffect });
                        logMessage(`${event.icon} ã€${event.name}ã€‘ ${stock.name}: ${event.description} ä»·æ ¼${priceEffect > 0 ? 'ä¸Šæ¶¨' : 'ä¸‹è·Œ'} ${Math.abs(priceEffect).toFixed(1)}%!`, 'event', '', false); // Log event for each stock
                    }
                });
            }
            lastMarketEventHappened = currentDayEvents; // Store all events that happened today
        }

        function getQuantity(inputElement) {
            const value = inputElement.value.trim();
            const parsedValue = parseInt(value);
            if (value === '' || isNaN(parsedValue) || parsedValue <= 0) {
                // For player actions, using a default when nothing is entered is good UX.
                // For AI, quantities are typically calculated within its logic.
                return DEFAULT_TRADE_QUANTITY;
            }
            return parsedValue;
        }

        function buyStock(index, quantity, isAI = false, updateImmediate = true) {
            if (!gameRunning || quantity <= 0) return false;
            const stock = stocks[index];
            const cost = stock.price * quantity;
            const transactionFee = cost * (TRANSACTION_FEE_PERCENT / 100); // Calculate fee

            if (cash >= cost + transactionFee) { // Check if cash is enough for cost + fee
                // Update AI's assumed average buy price (still used for AI trade history display)
                if (isAI) {
                    const currentTotalCost = (aiBoughtPrices[stock.name] || 0) * stock.sharesOwned;
                    aiBoughtPrices[stock.name] = (currentTotalCost + cost) / (stock.sharesOwned + quantity);
                    // Record AI trade
                    aiTradeHistory.push({
                        day: currentDay,
                        type: 'Buy',
                        stockName: stock.name,
                        quantity: quantity,
                        price: stock.price
                    });
                }

                cash -= (cost + transactionFee); // Deduct cost and fee
                stock.sharesOwned += quantity;
                totalTrades++; // Increment total trades
                totalFees += transactionFee; // Add to total fees

                // Only log detailed buy if not AI (AI logs its own decision)
                if (!isAI) {
                    logMessage(`ä¹°å…¥ ${quantity} è‚¡ ${stock.name} @ ${formatCurrency(stock.price)}ã€‚èŠ±è´¹: ${formatCurrency(cost)} (å«ç¨è´¹: ${formatCurrency(transactionFee)})`, 'success', 'âœ…');
                }
                if (updateImmediate) updateUI();
                return true;
            } else {
                if (!isAI) logMessage(`èµ„é‡‘ä¸è¶³ä¹°å…¥ ${quantity} è‚¡ ${stock.name}ã€‚éœ€è¦ ${formatCurrency(cost + transactionFee)}ï¼Œç°æœ‰ ${formatCurrency(cash)}ã€‚`, 'error', 'âŒ');
                return false;
            }
        }

        function sellStock(index, quantity, isAI = false, updateImmediate = true) {
            if (!gameRunning || quantity <= 0) return false;
            const stock = stocks[index];
            if (stock.sharesOwned >= quantity) {
                const earnings = stock.price * quantity;
                const transactionFee = earnings * (TRANSACTION_FEE_PERCENT / 100); // Calculate fee

                cash += (earnings - transactionFee); // Add earnings, deduct fee
                stock.sharesOwned -= quantity;
                totalTrades++; // Increment total trades
                totalFees += transactionFee; // Add to total fees

                // If AI sells all shares, remove from aiBoughtPrices
                if (isAI) {
                    if (stock.sharesOwned === 0 && aiBoughtPrices[stock.name]) {
                        delete aiBoughtPrices[stock.name];
                    }
                    // Record AI trade
                    aiTradeHistory.push({
                        day: currentDay,
                        type: 'Sell',
                        stockName: stock.name,
                        quantity: quantity,
                        price: stock.price
                    });
                }
                 // If AI sells partial, and we're tracking average, might need to re-calculate, but simplified it's just removed when shares hit 0

                // Only log detailed sell if not AI (AI logs its own decision)
                if (!isAI) {
                    logMessage(`å–å‡º ${quantity} è‚¡ ${stock.name} @ ${formatCurrency(stock.price)}ã€‚è·å¾—: ${formatCurrency(earnings)} (æ‰£é™¤ç¨è´¹: ${formatCurrency(transactionFee)})`, 'success', 'ğŸ“ˆ');
                }
                if (updateImmediate) updateUI();
                return true;
            } else {
                if (!isAI) logMessage(`æ— æ³•å–å‡º ${quantity} è‚¡ ${stock.name}ï¼ŒåªæŒæœ‰ ${stock.sharesOwned} è‚¡ã€‚`, 'error', 'ğŸš«');
                return false;
            }
        }

        function closePosition(index) {
            const stock = stocks[index];
            if (stock.sharesOwned > 0) {
                logMessage(`æ­£åœ¨å¹³ä»“ ${stock.name} (å…± ${stock.sharesOwned} è‚¡)...`, 'info', 'âš¡');
                sellStock(index, stock.sharesOwned, false, true); // Close position is a manual action, update immediately
            } else {
                logMessage(`æ— æ³•å¹³ä»“ ${stock.name}ï¼ŒæœªæŒæœ‰è¯¥è‚¡ç¥¨ã€‚`, 'warn', 'âš ï¸');
            }
        }

        function nextDay() {
            if (!gameRunning && currentDay === 0) {
                logMessage("æ¸¸æˆæ­£å¼å¼€å§‹! Day 0ã€‚", 'info');
                logMessage("å¸‚åœºç¬æ¯ä¸‡å˜ï¼ŒæŠ“ä½æœºä¼šï¼Œåˆ›é€ è´¢å¯Œ!", 'info');
                nextDayButton.textContent = "ä¸‹ä¸€å¤©";
                // Enable all strategy buttons after game starts (Day 0)
                strategy1Button.disabled = false;
                strategy2Button.disabled = false;
                strategy3Button.disabled = false;
                strategy4Button.disabled = false;
                strategy5Button.disabled = false;
                strategy6Button.disabled = false;
                strategy7Button.disabled = false;
                strategy8Button.disabled = false;

                buyAllStocksButton.disabled = false; // Enable Buy All Stocks button
                sellAllButton.disabled = false; // Enable bulk sell buttons
                sellHalfButton.disabled = false;
                sellQuarterButton.disabled = false;
                gameRunning = true;
                updateUI(); // Updates currentDay to 0, renders table etc.
                return; // Stop execution, Day 0 display
            }

            if (!gameRunning) return; // Prevent action if game already ended

            // Clear events from previous day before new ones are generated
            lastMarketEventHappened = [];

            if (currentDay >= MAX_DAYS) {
                endGame();
                return;
            }

            currentDay++;
            logMessage(`ğŸ“… === ç¬¬ ${currentDay} å¤© ===`, 'info');
            updateStockPrices(); // Prices change for the new day
            updateUI(); // Table shows new prices and change indicators

            if (currentDay === MAX_DAYS) {
                logMessage("ğŸ¯ æœ€åä¸€å¤©ã€‚äº¤æ˜“ç»“æŸã€‚ç‚¹å‡»æŒ‰é’®æŸ¥çœ‹æœ€ç»ˆç»“æœã€‚", 'info', 'ğŸ');
                nextDayButton.textContent = "æ˜¾ç¤ºç»“æœ";
                // Disable all strategy buttons on final day
                strategy1Button.disabled = true;
                strategy2Button.disabled = true;
                strategy3Button.disabled = true;
                strategy4Button.disabled = true;
                strategy5Button.disabled = true;
                strategy6Button.disabled = true;
                strategy7Button.disabled = true;
                strategy8Button.disabled = true;
                buyAllStocksButton.disabled = true; // Disable buy all button on final day
                sellAllButton.disabled = true; // Disable bulk sell buttons on final day
                sellHalfButton.disabled = true;
                sellQuarterButton.disabled = true;
            }
        }

        function endGame() {
            gameRunning = false;
            logMessage("ğŸ === æ¸¸æˆç»“æŸ ===", 'info');

            // --- Robustness: Ensure cash is a valid number ---
            if (isNaN(cash)) {
                logMessage("ä¸¥é‡é”™è¯¯: ç°é‡‘å€¼å˜ä¸ºNaNã€‚å¯èƒ½å‘ç”Ÿäº†å†…éƒ¨è®¡ç®—é”™è¯¯ã€‚æ¸¸æˆå°†å°è¯•ä½¿ç”¨åˆå§‹èµ„é‡‘è¿›è¡Œç»“ç®—ã€‚", 'error', 'ğŸš¨');
                cash = INITIAL_CASH; // Reset cash to initial value to attempt recovery
            }

            let liquidationValue = 0;
            stocks.forEach(stock => {
                if (stock.sharesOwned > 0) {
                    const value = stock.price * stock.sharesOwned;
                    if (isNaN(value) || !isFinite(value)) { // Check for NaN or Infinity
                        logMessage(`è­¦å‘Š: è‚¡ç¥¨ ${stock.name} çš„æ¸…ç®—ä»·å€¼æ— æ•ˆ (NaN/Infinity)ã€‚è¯¥éƒ¨åˆ†å°†ä¸è®¡å…¥ã€‚`, 'warn', 'âš ï¸');
                        return; // Skip this stock's value calculation if invalid
                    }
                    liquidationValue += value;
                    logMessage(`ğŸ’¸ å¼ºåˆ¶å¹³ä»“ ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(stock.price)} = ${formatCurrency(value)}`);
                    stock.sharesOwned = 0; // Clear shares after liquidation
                }
            });
            // Ensure liquidationValue is a number before adding to cash
            if (isNaN(liquidationValue) || !isFinite(liquidationValue)) {
                logMessage("è­¦å‘Š: æ€»æ¸…ç®—ä»·å€¼è®¡ç®—ç»“æœæ— æ•ˆ (NaN/Infinity)ï¼Œå°†è§†ä¸º0ã€‚", 'warn', 'âš ï¸');
                liquidationValue = 0;
            }
            cash += liquidationValue;

            // --- Ensure finalNetWorth is a valid number ---
            let finalNetWorth = calculateNetWorth();
            if (isNaN(finalNetWorth) || !isFinite(finalNetWorth)) { // Check for NaN or Infinity
                logMessage("è­¦å‘Š: æœ€ç»ˆèµ„äº§è®¡ç®—ç»“æœæ— æ•ˆ (NaN/Infinity)ã€‚å°†ä½¿ç”¨å½“å‰ç°é‡‘å€¼ä½œä¸ºæœ€ç»ˆèµ„äº§ã€‚", 'warn', 'âš ï¸');
                finalNetWorth = cash; // Fallback to current cash (which we ensured is valid)
            }

            const profitLoss = finalNetWorth - INITIAL_CASH;
            let profitLossPercent = 0;

            // Handle division by zero for profitLossPercent if INITIAL_CASH is 0 (though not the case here)
            // Or if finalNetWorth is equal to INITIAL_CASH (0 profit/loss) to prevent 0/0 = NaN
            if (INITIAL_CASH === 0) {
                if (finalNetWorth === 0) {
                    profitLossPercent = 0; // 0/0 case, or truly no change
                } else {
                    profitLossPercent = Infinity; // Or a very large number, or just show finalNetWorth
                }
            } else {
                profitLossPercent = (finalNetWorth - INITIAL_CASH) / INITIAL_CASH * 100;
            }

            // Ensure profitLossPercent is a number
            if (isNaN(profitLossPercent) || !isFinite(profitLossPercent)) {
                profitLossPercent = 0; // Default to 0 if NaN or Infinity
            }

            initialCapitalResult.textContent = formatCurrency(INITIAL_CASH);
            finalNetWorthResult.textContent = formatCurrency(finalNetWorth);

            if (profitLoss >= 0) {
                profitLossResult.style.color = 'var(--profit-color)';
                profitLossResult.textContent = formatCurrency(profitLoss) + ' ğŸ‰';
                logMessage(`ğŸŠ æ­å–œ! æ‚¨è·å¾—äº† ${formatCurrency(profitLoss)} çš„åˆ©æ¶¦!`, 'profit');
            } else {
                profitLossResult.style.color = 'var(--loss-color)';
                profitLossResult.textContent = formatCurrency(profitLoss) + ' ğŸ˜¢';
                logMessage(`ğŸ˜ é—æ†¾! æ‚¨äºæŸäº† ${formatCurrency(-profitLoss)}ã€‚å†æ¥å†å‰!`, 'loss');
            }

            // Determine player title based on final net worth
            let playerTitle = "éŸ­èœæŠ•èµ„äºº (äºæŸå¤§æˆ·)"; // Default for loss
            if (finalNetWorth > INITIAL_CASH) { // Only calculate percentage if there's a profit
                if (profitLossPercent >= 30) {
                    playerTitle = "å¤©ä¹‹éª„å­ (è‚¡å¸‚ä¼ å¥‡)";
                } else if (profitLossPercent >= 16) {
                    playerTitle = "é‡‘èå¤§äº¨ (ä¸€æ–¹éœ¸ä¸»)";
                } else if (profitLossPercent >= 11) {
                    playerTitle = "æŠ•èµ„è¾¾äºº (ç‹¬å…·æ…§çœ¼)";
                } else if (profitLossPercent >= 6) {
                    playerTitle = "ç²¾è‹±äº¤æ˜“å‘˜ (å´­éœ²å¤´è§’)";
                } else if (profitLossPercent >= 3) {
                    playerTitle = "ç¨³å¥ç†è´¢äºº (æ”¶ç›Šå°šå¯)";
                }
            }
            playerTitleDisplay.textContent = playerTitle;
            logMessage(`æ‚¨çš„æœ€ç»ˆç§°å·æ˜¯ï¼š${playerTitle}`, 'info', 'ğŸ†');

            // --- End Display new detailed statistics ---
            profitLossPercentageResult.textContent = `${profitLossPercent.toFixed(2)}%`;
            usedStrategyDisplay.textContent = activeStrategyName;
            peakNetWorthDisplay.textContent = formatCurrency(peakNetWorth);
            troughNetWorthDisplay.textContent = formatCurrency(troughNetWorth);
            // --- End Display new detailed statistics ---

            displayAiTradeHistory(); // Display AI trade history

            // Display new statistics
            document.getElementById('finalTotalTrades').textContent = totalTrades;
            document.getElementById('finalTotalFees').textContent = formatCurrency(totalFees);

            // Ensure all buttons are in correct state at game end
            nextDayButton.disabled = true;
            // Ensure all strategy buttons are disabled after simulation
            strategy1Button.disabled = true;
            strategy2Button.disabled = true;
            strategy3Button.disabled = true;
            strategy4Button.disabled = true;
            strategy5Button.disabled = true;
            strategy6Button.disabled = true;
            strategy7Button.disabled = true;
            strategy8Button.disabled = true;
            
            // Force liquidation of all positions
            stocks.forEach(stock => {
                if (stock.sharesOwned > 0) {
                    const value = stock.price * stock.sharesOwned;
                    cash += value;
                    stock.sharesOwned = 0;
                }
            });
            
            // Final UI update
            updateUI();
            
            // Show game over screen
            gameOverScreen.style.display = 'flex';
            
            // Show confetti if profit
            if (profitLoss > 0 && typeof confetti === 'function') {
                confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
            }
        }

        // Function to display AI trade history
        function displayAiTradeHistory() {
            aiTradeHistoryDisplay.innerHTML = '<h3>AI äº¤æ˜“è®°å½•</h3>';
            if (aiTradeHistory.length === 0) {
                aiTradeHistoryDisplay.innerHTML += '<p>AI æœªæ‰§è¡Œä»»ä½•äº¤æ˜“ã€‚</p>';
                return;
            }

            const ul = document.createElement('ul');
            aiTradeHistory.forEach(trade => {
                const li = document.createElement('li');
                const actionColor = trade.type === 'Buy' ? 'var(--profit-color)' : 'var(--loss-color)';
                li.innerHTML = `å¤© ${trade.day}: <strong style="color: ${actionColor};">${trade.type === 'Buy' ? 'ä¹°å…¥' : 'å–å‡º'}</strong> ${trade.quantity} è‚¡ ${trade.stockName} @ ${formatCurrency(trade.price)}`;
                ul.appendChild(li);
            });
            aiTradeHistoryDisplay.appendChild(ul);
        }

        // --- Event Listeners for individual stock actions and swipe ---
        function attachActionListeners() {
            stockTableBody.querySelectorAll('button').forEach(button => {
                button.onclick = handleActionClick;
            });
            stockTableBody.querySelectorAll('input[type="number"]').forEach(input => {
                input.addEventListener('touchstart', handleQtyTouchStart, { passive: true });
                input.addEventListener('touchmove', handleQtyTouchMove, { passive: false }); // Prevent default scroll for gesture
                input.addEventListener('touchend', handleQtyTouchEnd, { passive: true });
                input.addEventListener('touchcancel', handleQtyTouchEnd, { passive: true });
            });
        }

        function handleActionClick(e) {
            const button = e.target;
            const index = parseInt(button.getAttribute('data-index'));
            const quantityInput = document.getElementById(`qty-${index}`);
            if (button.classList.contains('buy-button')) {
                const quantity = getQuantity(quantityInput); buyStock(index, quantity, false);
            } else if (button.classList.contains('sell-button')) {
                const quantity = getQuantity(quantityInput); sellStock(index, quantity, false);
            } else if (button.classList.contains('close-button')) {
                closePosition(index);
            }
            quantityInput.value = ''; // Clear input after action
        }

        function handleQtyTouchStart(e) {
            if (e.touches.length === 1) { swipeStartY = e.touches[0].clientY; isSwiping = true; }
            else { isSwiping = false; }
        }
        function handleQtyTouchMove(e) {
            if (!isSwiping || e.touches.length !== 1) return;
            const currentY = e.touches[0].clientY; const deltaY = swipeStartY - currentY;

            let quantityChanged = false;

            if (deltaY > SWIPE_THRESHOLD_PX) { // Swiping up
                const inputElement = e.target; let currentValue = parseInt(inputElement.value) || 0;
                currentValue += SWIPE_INCREMENT_QUANTITY; inputElement.value = currentValue;
                swipeStartY = currentY; // Reset start position for continuous swipe
                quantityChanged = true;
            } else if (deltaY < -SWIPE_THRESHOLD_PX) { // Swiping down
                const inputElement = e.target; let currentValue = parseInt(inputElement.value) || 0;
                currentValue = Math.max(0, currentValue - SWIPE_INCREMENT_QUANTITY); inputElement.value = currentValue;
                swipeStartY = currentY; // Reset start position for continuous swipe
                quantityChanged = true;
            }

            if (quantityChanged) {
                if (navigator.vibrate) { navigator.vibrate(20); } // Haptic feedback
                e.preventDefault(); // Prevent page scrolling
            } else if (Math.abs(deltaY) > 5) { // If there's a small movement but not enough for quantity change, still prevent scroll to make it feel responsive
                e.preventDefault();
            }
        }
        function handleQtyTouchEnd(e) { isSwiping = false; swipeStartY = 0; }

        // --- Bulk Sell Functions ---
        function bulkSell(percentage) {
             if (!gameRunning) return;

             const actionText = percentage === 1 ? "å…¨ä»“" : percentage === 0.5 ? "åŠä»“" : percentage === 0.25 ? "å››åˆ†ä¹‹ä¸€ä»“" : "éƒ¨åˆ†";
             logMessage(`å°è¯•${actionText}å–å‡ºæ‰€æœ‰æŒä»“è‚¡ç¥¨...`, 'info', 'ğŸ“‰');
             let stocksSoldCount = 0;

             stocks.forEach((stock, index) => {
                 if (stock.sharesOwned > 0) {
                     const quantityToSell = Math.floor(stock.sharesOwned * percentage);
                     // Ensure quantity is at least 1 if percentage is positive and shares owned > 0
                     const actualQuantityToSell = percentage > 0 ? Math.max(1, quantityToSell) : 0;
                     // Do not sell more than owned
                     const finalQuantityToSell = Math.min(actualQuantityToSell, stock.sharesOwned);

                     if (finalQuantityToSell > 0) {
                          // Use sellStock function, but mark as manual (isAI = false)
                          if (sellStock(index, finalQuantityToSell, false, false)) {
                               stocksSoldCount++;
                          }
                     }
                 }
             });

             if (stocksSoldCount > 0) {
                 logMessage(`æˆåŠŸ${actionText}å–å‡º ${stocksSoldCount} åªè‚¡ç¥¨ã€‚`, 'success', 'âœ…');
             } else {
                 logMessage(`æœªèƒ½${actionText}å–å‡ºä»»ä½•è‚¡ç¥¨ (å¯èƒ½æ²¡æœ‰æŒä»“æˆ–è®¡ç®—æ•°é‡ä¸è¶³1è‚¡)ã€‚`, 'warn', 'âš ï¸');
             }
             updateUI(); // Update UI after attempting sells
        }

        function sellAllStocks() { bulkSell(1); }
        function sellHalfStocks() { bulkSell(0.5); }
        function sellQuarterStocks() { bulkSell(0.25); }

        // Add a delay for the AI simulation loop
        const SIMULATION_DAY_DELAY_MS = 200; // Milliseconds delay between days

        // New function to run the AI simulation, takes a strategy function as argument
        async function runAiSimulation(strategyLogic, strategyName = "AI åŠ©æ‰‹") {
            if (!gameRunning || currentDay === 0 || currentDay >= MAX_DAYS) {
                if (currentDay === 0) {
                    logMessage("è‡ªåŠ¨äº¤æ˜“: éœ€è¦è‡³å°‘ä¸€å¤©çš„æ•°æ®æ‰èƒ½å¼€å§‹æ¨¡æ‹Ÿï¼Œè¯·å…ˆè¿›å…¥ä¸‹ä¸€å¤©ã€‚", 'warn');
                } else if (currentDay >= MAX_DAYS) {
                    logMessage("è‡ªåŠ¨äº¤æ˜“: æ¸¸æˆå·²è¾¾åˆ°æœ€å¤§å¤©æ•°ï¼Œæ¨¡æ‹Ÿç»“æŸã€‚", 'warn');
                }
                return;
            }

            activeStrategyName = strategyName; // Update the active strategy name
            logMessage(`${strategyName}: å¼€å§‹è‡ªåŠ¨æ¨¡æ‹Ÿ...`, 'ai', 'ğŸ¤–');

            // Disable buttons during simulation
            nextDayButton.disabled = true;
            strategy1Button.disabled = true;
            strategy2Button.disabled = true;
            strategy3Button.disabled = true;
            strategy4Button.disabled = true;
            strategy5Button.disabled = true;
            strategy6Button.disabled = true;
            strategy7Button.disabled = true;
            strategy8Button.disabled = true;

            while (gameRunning && currentDay < MAX_DAYS) {
                // å…ˆæ¨è¿›åˆ°ä¸‹ä¸€å¤©å¹¶æ›´æ–°ä»·æ ¼/äº‹ä»¶ï¼Œè¿™æ ·ç­–ç•¥æ‰èƒ½å¯¹æœ€æ–°æ•°æ®åšå‡ºååº”
                nextDay(); 

                // åœ¨æ¨è¿›å¤©æ•°åæ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸï¼ˆä¾‹å¦‚è¾¾åˆ°æœ€å¤§å¤©æ•°ï¼‰
                if (!gameRunning || currentDay >= MAX_DAYS) {
                    break;
                }
                
                // ç°åœ¨ï¼Œæ‰§è¡Œé€‰å®šç­–ç•¥çš„äº¤æ˜“ï¼Œå®ƒä»¬å°†åŸºäºåˆšåˆšæ›´æ–°çš„å½“å‰å¤©æ•°æ®
                strategyLogic(); 
                
                // Add delay between days
                await new Promise(resolve => setTimeout(resolve, SIMULATION_DAY_DELAY_MS));
            }

            // Ensure buttons are properly enabled/disabled after simulation
            nextDayButton.disabled = !gameRunning;
            // Re-enable strategy buttons if game is still running and not on final day
            if (gameRunning && currentDay < MAX_DAYS) {
                strategy1Button.disabled = false;
                strategy2Button.disabled = false;
                strategy3Button.disabled = false;
                strategy4Button.disabled = false;
                strategy5Button.disabled = false;
                strategy6Button.disabled = false;
                strategy7Button.disabled = false;
                strategy8Button.disabled = false;
            }
            // If game ended, endGame() already disabled them

            logMessage(`${strategyName}: è‡ªåŠ¨æ¨¡æ‹Ÿç»“æŸã€‚`, 'ai', 'ğŸ');
            updateUI(); // Update UI after strategy actions
        }

        // Helper for SMA calculation
        function calculateSMA(stockName, period) {
            const prices = historicalPrices[stockName];
            if (!prices || prices.length < period) return null; // Not enough data
            const relevantPrices = prices.slice(-period);
            const sum = relevantPrices.reduce((a, b) => a + b, 0);
            return sum / period;
        }

        // --- Strategy 1: æ¶¨è·Œå¹…è¿½å‡»è€… (Volatility Chaser) ---
        const VOLATILITY_CHASER_BUY_DROP_PERCENT = 3;   // è·Œå¹…è¶…è¿‡3%ä¹°å…¥ (åŸ: 5)
        const VOLATILITY_CHASER_SELL_RISE_PERCENT = 2;  // æ¶¨å¹…è¶…è¿‡2%å–å‡º (åŸ: 3)
        const VOLATILITY_CHASER_PROFIT_TAKE_PERCENT = 7; // æ­¢ç›ˆï¼šç›¸è¾ƒä¹°å…¥ä»·ä¸Šæ¶¨7%å–å‡º (åŸ: 10)
        const VOLATILITY_CHASER_STOP_LOSS_PERCENT = 3;  // æ­¢æŸï¼šç›¸è¾ƒä¹°å…¥ä»·ä¸‹è·Œ3%å–å‡º (åŸ: 5)
        const VOLATILITY_CHASER_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 2; // æ¯æ¬¡äº¤æ˜“æ•°é‡
        const VOLATILITY_CHASER_MAX_CASH_PER_TRADE_PERCENT = 0.01; // æ¯æ¬¡äº¤æ˜“æŠ•å…¥æ€»ç°é‡‘çš„1%

        function strategy1Logic() {
            let actionsTaken = 0;
            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const prevPrice = previousPrices[stock.name];
                if (prevPrice === undefined || prevPrice === null || prevPrice === 0) return; // Need previous day data

                const percentageChange = ((currentPrice - prevPrice) / prevPrice) * 100;
                const assumedBuyPrice = aiBoughtPrices[stock.name]; // AI's recorded buy price

                // Sell Logic (Priority: Stop Loss then Profit Take then Daily Rise)
                if (stock.sharesOwned > 0) {
                    // Stop Loss
                    if (assumedBuyPrice && ((assumedBuyPrice - currentPrice) / assumedBuyPrice) * 100 >= VOLATILITY_CHASER_STOP_LOSS_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 1 (è¿½å‡»è€…): æ­¢æŸå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (äºæŸ: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸ”´', false);
                        }
                        return; // Done with this stock for selling, prevent further actions
                    }

                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= VOLATILITY_CHASER_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 1 (è¿½å‡»è€…): æ­¢ç›ˆå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (åˆ©æ¶¦: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸŸ¢', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Daily Rise Sell
                    if (percentageChange >= VOLATILITY_CHASER_SELL_RISE_PERCENT) {
                        // Sell a portion, e.g., 50% or fixed quantity, or all if small holding
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned / 2)); // Sell half or default
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 1 (è¿½å‡»è€…): æ¶¨å¹…è¾¾æ ‡å–å‡º ${quantityToSell} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (+${percentageChange.toFixed(2)}%)`, 'ai', 'ğŸ“ˆ', false);
                        }
                    }
                }

                // Buy Logic (Only if not held or if selling action wasn't taken)
                // Ensure we have enough cash to buy at least a small quantity
                if (cash > currentPrice * MIN_PRICE && percentageChange <= -VOLATILITY_CHASER_BUY_DROP_PERCENT) {
                    const maxAffordableQuantity = Math.floor(cash * VOLATILITY_CHASER_MAX_CASH_PER_TRADE_PERCENT / currentPrice);
                    const quantityToBuy = Math.min(VOLATILITY_CHASER_TRADE_QUANTITY, maxAffordableQuantity);

                    if (quantityToBuy > 0) {
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 1 (è¿½å‡»è€…): è·Œå¹…è¾¾æ ‡ä¹°å…¥ ${quantityToBuy} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (${percentageChange.toFixed(2)}%)`, 'ai', 'ğŸ“‰', false);
                        }
                    }
                }
            });
            if (actionsTaken > 0) {
                logMessage(`ç­–ç•¥ 1 (è¿½å‡»è€…): æœ¬è½®å®Œæˆ ${actionsTaken} ç¬”äº¤æ˜“ã€‚`, 'ai', 'âœ…');
            } else {
                logMessage(`ç­–ç•¥ 1 (è¿½å‡»è€…): æœ¬è½®æœªæ‰§è¡Œä»»ä½•äº¤æ˜“ã€‚`, 'ai', 'â„¹ï¸', false);
            }
            updateUI(); // Update UI after strategy actions
        }

        // --- Strategy 2: ä»·å€¼æŠ•èµ„è€… (Value Investor) ---
        const VALUE_INVESTOR_CHEAP_PRICE_THRESHOLD = 50; // ä»·æ ¼ä½äº50å…ƒè§†ä¸ºä¾¿å®œè‚¡
        const VALUE_INVESTOR_AVG_PRICE_PERCENT_THRESHOLD = 0.8; // ä»·æ ¼ä½äºå¹³å‡ä»·æ ¼çš„80%è§†ä¸ºä¾¿å®œè‚¡
        const VALUE_INVESTOR_PROFIT_TAKE_PERCENT = 25; // æ­¢ç›ˆï¼šç›¸è¾ƒä¹°å…¥ä»·ä¸Šæ¶¨25%å–å‡º
        const VALUE_INVESTOR_HOLD_QUANTITY_LIMIT = 500; // å•åªè‚¡ç¥¨æŒä»“ä¸Šé™
        const VALUE_INVESTOR_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY; // æ¯æ¬¡äº¤æ˜“æ•°é‡

        function strategy2Logic() {
            let actionsTaken = 0;

            const totalStockPrices = stocks.reduce((sum, stock) => sum + stock.price, 0);
            const averageStockPrice = totalStockPrices / stocks.length;

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Profit Take)
                if (stock.sharesOwned > 0 && assumedBuyPrice) {
                    const profitPercent = ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100;
                    if (profitPercent >= VALUE_INVESTOR_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 2 (ä»·å€¼æŠ•èµ„è€…): æ­¢ç›ˆå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (åˆ©æ¶¦: ${profitPercent.toFixed(2)}%)`, 'ai', 'ğŸ’°', false);
                        }
                    }
                }

                // Buy Logic (Only if not held or held below limit and price is low)
                if (cash > currentPrice * MIN_PRICE && stock.sharesOwned < VALUE_INVESTOR_HOLD_QUANTITY_LIMIT) {
                    const isCheapByAbsolute = currentPrice < VALUE_INVESTOR_CHEAP_PRICE_THRESHOLD;
                    const isCheapByRelative = currentPrice < averageStockPrice * VALUE_INVESTOR_AVG_PRICE_PERCENT_THRESHOLD;

                    if (isCheapByAbsolute || isCheapByRelative) {
                        const quantityToBuy = VALUE_INVESTOR_TRADE_QUANTITY;
                        if (cash >= currentPrice * quantityToBuy) {
                            if (buyStock(index, quantityToBuy, true, false)) {
                                actionsTaken++;
                                logMessage(`ç­–ç•¥ 2 (ä»·å€¼æŠ•èµ„è€…): å‘ç°ä»·å€¼è‚¡ä¹°å…¥ ${quantityToBuy} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)}`, 'ai', 'ğŸ’', false);
                            }
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`ç­–ç•¥ 2 (ä»·å€¼æŠ•èµ„è€…): æœ¬è½®å®Œæˆ ${actionsTaken} ç¬”äº¤æ˜“ã€‚`, 'ai', 'âœ…');
            } else {
                logMessage(`ç­–ç•¥ 2 (ä»·å€¼æŠ•èµ„è€…): æœ¬è½®æœªæ‰§è¡Œä»»ä½•äº¤æ˜“ã€‚`, 'ai', 'â„¹ï¸', false);
            }
            updateUI();
        }

        // --- Strategy 3: äº‹ä»¶å“åº”è€… (Event Responder) ---
        const EVENT_RESPONDER_PROFIT_PERCENT_FOR_POSITIVE_EVENT = 8; // å› ç§¯æäº‹ä»¶ä¹°å…¥çš„è‚¡ç¥¨ï¼Œä¸Šæ¶¨8%åå–å‡º (åŸ: 10)
        const EVENT_RESPONDER_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 5; // æ¯æ¬¡äº¤æ˜“æ•°é‡æ›´å¤§

        function strategy3Logic() {
            let actionsTaken = 0;

            const currentDayEvents = lastMarketEventHappened; // Get all events for the current day
            // Removed: lastMarketEventHappened = []; // Reset for next day

            // Process all events that happened today
            currentDayEvents.forEach(eventData => {
                const event = eventData.event;
                const affectedStock = eventData.stock;
                const index = stocks.indexOf(affectedStock);
                if (index === -1) return; // Stock not found, skip

                // React to Negative Event: Sell immediately
                if (event.type === 'negative') {
                    if (affectedStock.sharesOwned > 0) {
                        if (sellStock(index, affectedStock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 3 (äº‹ä»¶å“åº”è€…): å› ã€${event.name}ã€‘æ­¢æŸå–å‡º ${affectedStock.sharesOwned} è‚¡ ${affectedStock.name}ã€‚`, 'ai', event.icon, false);
                        }
                    }
                }
                // React to Positive Event: Buy
                else if (event.type === 'positive') {
                    if (cash > affectedStock.price * MIN_PRICE) {
                        const quantityToBuy = Math.min(EVENT_RESPONDER_TRADE_QUANTITY, Math.floor(cash / affectedStock.price));
                        if (quantityToBuy > 0) {
                            if (buyStock(index, quantityToBuy, true, false)) {
                                actionsTaken++;
                                logMessage(`ç­–ç•¥ 3 (äº‹ä»¶å“åº”è€…): å› ã€${event.name}ã€‘ä¹°å…¥ ${quantityToBuy} è‚¡ ${affectedStock.name}ã€‚`, 'ai', event.icon, false);
                            }
                        }
                    }
                }
            });

            // Additional logic: Sell existing holdings if they have made significant profit, regardless of current event
            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const assumedBuyPrice = aiBoughtPrices[stock.name];
                if (stock.sharesOwned > 0 && assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= EVENT_RESPONDER_PROFIT_PERCENT_FOR_POSITIVE_EVENT) {
                    if (sellStock(index, stock.sharesOwned, true, false)) {
                        actionsTaken++;
                        logMessage(`ç­–ç•¥ 3 (äº‹ä»¶å“åº”è€…): æ­¢ç›ˆå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (åˆ©æ¶¦: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸ’°', false);
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`ç­–ç•¥ 3 (äº‹ä»¶å“åº”è€…): æœ¬è½®å®Œæˆ ${actionsTaken} ç¬”äº¤æ˜“ã€‚`, 'ai', 'âœ…');
            } else {
                logMessage(`ç­–ç•¥ 3 (äº‹ä»¶å“åº”è€…): æœ¬è½®æœªæ‰§è¡Œä»»ä½•äº¤æ˜“ã€‚`, 'ai', 'â„¹ï¸', false);
            }
            updateUI();
        }

        // --- Strategy 4: å°æ­¥å¿«è·‘è€… (Scalper/Day Trader) ---
        const SCALPER_BUY_RISE_MIN_PERCENT = 0.1; // ä»·æ ¼ä¸Šæ¶¨0.1%ä»¥ä¸Šè€ƒè™‘ä¹°å…¥ (åŸ: 0.2)
        const SCALPER_BUY_RISE_MAX_PERCENT = 0.5;   // ä»·æ ¼ä¸Šæ¶¨è¶…è¿‡0.5%ä¸è¿½é«˜ä¹°å…¥ (åŸ: 1)
        const SCALPER_PROFIT_TAKE_PERCENT = 0.8;   // æ­¢ç›ˆï¼šç›¸è¾ƒä¹°å…¥ä»·ä¸Šæ¶¨0.8%å–å‡º (åŸ: 1)
        const SCALPER_DAILY_DROP_SELL_PERCENT = 0.1; // å½“æ—¥ä»·æ ¼ä¸‹è·Œ0.1%åˆ™å–å‡ºï¼ˆå³ä½¿å°äºï¼‰ (åŸ: 0.2)
        const SCALPER_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY / 2; // æ¯æ¬¡äº¤æ˜“æ•°é‡è¾ƒå°

        function strategy4Logic() {
            let actionsTaken = 0;

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const prevPrice = previousPrices[stock.name];
                if (prevPrice === undefined || prevPrice === null || prevPrice === 0) return; // Need previous day data

                const percentageChange = ((currentPrice - prevPrice) / prevPrice) * 100;
                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Priority: Profit Take then Daily Drop Sell)
                if (stock.sharesOwned > 0) {
                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= SCALPER_PROFIT_TAKE_PERCENT) {
                        // Sell a portion, or all if small holding
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned * 0.5));
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 4 (å°æ­¥å¿«è·‘è€…): æ­¢ç›ˆå–å‡º ${quantityToSell} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (åˆ©æ¶¦: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸ“ˆ', false);
                        }
                        // Do not return here, as we might buy it again on the same day if conditions are met
                    }
                    // Daily Drop Sell
                    else if (percentageChange <= -SCALPER_DAILY_DROP_SELL_PERCENT) {
                        // Sell a portion, or all if small holding
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned * 0.3));
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 4 (å°æ­¥å¿«è·‘è€…): è¶‹åŠ¿åè½¬å–å‡º ${quantityToSell} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (${percentageChange.toFixed(2)}%)`, 'ai', 'ğŸ“‰', false);
                        }
                    }
                }

                // Buy Logic (Only if not held or held in small quantity and price is slightly rising/stable)
                if (cash > currentPrice * MIN_PRICE && stock.sharesOwned < SCALPER_TRADE_QUANTITY * 2) { // Only buy if not holding too much
                    if (percentageChange >= SCALPER_BUY_RISE_MIN_PERCENT && percentageChange <= SCALPER_BUY_RISE_MAX_PERCENT) {
                        const quantityToBuy = SCALPER_TRADE_QUANTITY;
                        if (cash >= currentPrice * quantityToBuy) {
                            if (buyStock(index, quantityToBuy, true, false)) {
                                actionsTaken++;
                                logMessage(`ç­–ç•¥ 4 (å°æ­¥å¿«è·‘è€…): å‘ç°å¾®æ¶¨ä¹°å…¥ ${quantityToBuy} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (+${percentageChange.toFixed(2)}%)`, 'ai', 'âš¡', false);
                            }
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`ç­–ç•¥ 4 (å°æ­¥å¿«è·‘è€…): æœ¬è½®å®Œæˆ ${actionsTaken} ç¬”äº¤æ˜“ã€‚`, 'ai', 'âœ…');
            } else {
                logMessage(`ç­–ç•¥ 4 (å°æ­¥å¿«è·‘è€…): æœ¬è½®æœªæ‰§è¡Œä»»ä½•äº¤æ˜“ã€‚`, 'ai', 'â„¹ï¸', false);
            }
            updateUI();
        }

        // --- Strategy 5: å¤šå…ƒåŒ–æŠ•èµ„è€… (Diversified Investor) ---
        const DIVERSIFIED_INVESTOR_TARGET_STOCKS = 50; // ç›®æ ‡æŒæœ‰50åªä¸åŒè‚¡ç¥¨
        const DIVERSIFIED_INVESTOR_MAX_SINGLE_STOCK_PERCENT_OF_PORTFOLIO = 0.03; // å•åªè‚¡ç¥¨å¸‚å€¼ä¸åº”è¶…è¿‡æ€»å¸‚å€¼çš„3%
        const DIVERSIFIED_INVESTOR_TRADE_QUANTITY = DEFAULT_TRADE_QUANTITY * 2; // æ¯æ¬¡äº¤æ˜“æ•°é‡
        const DIVERSIFIED_INVESTOR_TARGET_PORTFOLIO_PERCENT_OF_NET_WORTH = 0.60; // ç›®æ ‡æŒä»“å¸‚å€¼å æ€»èµ„äº§çš„æ¯”ä¾‹

        function strategy5Logic() {
            let actionsTaken = 0;

            const portfolioValue = calculatePortfolioValue();
            const netWorth = calculateNetWorth(); // Get current net worth
            const currentHeldStocksCount = stocks.filter(stock => stock.sharesOwned > 0).length;

            // å–å‡ºé€»è¾‘ï¼šå†å¹³è¡¡ï¼Œå–å‡ºå æ¯”è¿‡é«˜çš„è‚¡ç¥¨
            stocks.forEach((stock, index) => {
                if (stock.sharesOwned > 0) {
                    const stockCurrentValue = stock.price * stock.sharesOwned;
                    // é¿å…é™¤ä»¥é›¶ï¼Œç¡®ä¿ portfolioValue > 0
                    if (portfolioValue > 0 && (stockCurrentValue / portfolioValue) > DIVERSIFIED_INVESTOR_MAX_SINGLE_STOCK_PERCENT_OF_PORTFOLIO) {
                        // è®¡ç®—éœ€è¦å–å‡ºçš„æ•°é‡ä»¥è¾¾åˆ°ç›®æ ‡æƒé‡
                        const targetValue = portfolioValue * DIVERSIFIED_INVESTOR_MAX_SINGLE_STOCK_PERCENT_OF_PORTFOLIO;
                        const excessShares = stock.sharesOwned - Math.floor(targetValue / stock.price);
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(excessShares / 2)); // å–å‡ºè¶…é¢éƒ¨åˆ†çš„ä¸€åŠï¼Œè‡³å°‘é»˜è®¤æ•°é‡

                        if (quantityToSell > 0) {
                            if (sellStock(index, quantityToSell, true, false)) {
                                actionsTaken++;
                                logMessage(`ç­–ç•¥ 5 (å¤šå…ƒåŒ–): å†å¹³è¡¡å–å‡º ${quantityToSell} è‚¡ ${stock.name}ï¼Œå æ¯”è¿‡é«˜ã€‚`, 'ai', 'âš–ï¸', false);
                            }
                        }
                    }
                }
            });

            // ä¹°å…¥é€»è¾‘ï¼šå¢åŠ æŒä»“ç§ç±»ï¼Œæˆ–å¢åŠ ä½å æ¯”è‚¡ç¥¨ï¼ŒåŒæ—¶ç¡®ä¿æŒä»“å¸‚å€¼è¾¾åˆ°ç›®æ ‡æ¯”ä¾‹
            const targetPortfolioValue = netWorth * DIVERSIFIED_INVESTOR_TARGET_PORTFOLIO_PERCENT_OF_NET_WORTH;
            const cashToInvest = targetPortfolioValue - portfolioValue;

            // Only buy if current portfolio value is significantly less than target
            if (cashToInvest > 0 && cash > 0) {
                // Filter for stocks not excessively held and ideally at a good price
                const potentialBuyCandidates = stocks.filter(stock => {
                    const stockValue = stock.price * stock.sharesOwned;
                    // Consider buying if not held, or if held but its value is below max single stock percent of portfolio
                    return stock.sharesOwned === 0 || (portfolioValue > 0 && (stockValue / portfolioValue < DIVERSIFIED_INVESTOR_MAX_SINGLE_STOCK_PERCENT_OF_PORTFOLIO * 0.8)); // Buy if well below target single stock allocation
                });

                // Prioritize buying stocks to increase overall portfolio value, but also spread across candidates
                // Distribute cashToInvest among multiple stocks
                let remainingCashToInvest = cashToInvest; // Use cashToInvest as the budget
                let budgetPerStock = Math.min(remainingCashToInvest / Math.max(1, potentialBuyCandidates.length), DIVERSIFIED_INVESTOR_TRADE_QUANTITY * stocks[0].price * 2); // Limit per stock budget

                // Shuffle candidates to ensure diversity in buying order
                potentialBuyCandidates.sort(() => Math.random() - 0.5);

                for (let i = 0; i < potentialBuyCandidates.length && remainingCashToInvest > 0; i++) {
                    const stock = potentialBuyCandidates[i];
                    const index = stocks.indexOf(stock);

                    const maxQuantityAffordable = Math.floor(Math.min(remainingCashToInvest, budgetPerStock) / stock.price); // How much we can afford for this specific stock
                    const quantityToBuy = Math.max(DEFAULT_TRADE_QUANTITY, Math.min(DIVERSIFIED_INVESTOR_TRADE_QUANTITY, maxQuantityAffordable)); // Buy at least default, up to trade quantity, and what's affordable

                    if (quantityToBuy > 0 && cash >= stock.price * quantityToBuy) {
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            remainingCashToInvest -= (stock.price * quantityToBuy * (1 + TRANSACTION_FEE_PERCENT / 100)); // Deduct cost and fee
                            logMessage(`ç­–ç•¥ 5 (å¤šå…ƒåŒ–): ä¸ºç»´æŒç›®æ ‡ä»“ä½ä¹°å…¥ ${quantityToBuy} è‚¡ ${stock.name}ã€‚`, 'ai', 'ğŸ“ˆ', false);
                        }
                    }
                }
            }

            if (actionsTaken > 0) {
                logMessage(`ç­–ç•¥ 5 (å¤šå…ƒåŒ–): æœ¬è½®å®Œæˆ ${actionsTaken} ç¬”äº¤æ˜“ã€‚`, 'ai', 'âœ…');
            } else {
                logMessage(`ç­–ç•¥ 5 (å¤šå…ƒåŒ–): æœ¬è½®æœªæ‰§è¡Œä»»ä½•äº¤æ˜“ã€‚`, 'ai', 'â„¹ï¸', false);
            }
            updateUI();
        }

        // --- Strategy 6: è¶‹åŠ¿è¿½è¸ªè€… (Trend Follower) ---
        function strategy6Logic() {
            let actionsTaken = 0;

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const sma = calculateSMA(stock.name, TREND_FOLLOW_SMA_PERIOD);
                if (sma === null) return; // Not enough data for SMA

                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Priority: Stop Loss, Profit Take, then Trend Reversal)
                if (stock.sharesOwned > 0) {
                    // Stop Loss
                    if (assumedBuyPrice && ((assumedBuyPrice - currentPrice) / assumedBuyPrice) * 100 >= TREND_FOLLOW_STOP_LOSS_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 6 (è¶‹åŠ¿è¿½è¸ªè€…): æ­¢æŸå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (äºæŸ: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸ”´', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= TREND_FOLLOW_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 6 (è¶‹åŠ¿è¿½è¸ªè€…): æ­¢ç›ˆå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (åˆ©æ¶¦: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸŸ¢', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Trend Reversal Sell
                    if (currentPrice < sma * (1 - TREND_FOLLOW_SELL_BELOW_SMA_PERCENT / 100)) {
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned / 2)); // Sell half or default
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 6 (è¶‹åŠ¿è¿½è¸ªè€…): è¶‹åŠ¿åè½¬å–å‡º ${quantityToSell} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (ä½äºSMA)`, 'ai', 'ğŸ“‰', false);
                        }
                    }
                }

                // Buy Logic (Trend Following)
                if (stock.sharesOwned === 0 && cash > currentPrice * MIN_PRICE) { // Only buy if not held and enough cash
                    if (currentPrice > sma * (1 + TREND_FOLLOW_BUY_ABOVE_SMA_PERCENT / 100)) {
                        const quantityToBuy = TREND_FOLLOW_TRADE_QUANTITY;
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 6 (è¶‹åŠ¿è¿½è¸ªè€…): è¶‹åŠ¿ç¡®è®¤ä¹°å…¥ ${quantityToBuy} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (é«˜äºSMA)`, 'ai', 'ğŸ“ˆ', false);
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`ç­–ç•¥ 6 (è¶‹åŠ¿è¿½è¸ªè€…): æœ¬è½®å®Œæˆ ${actionsTaken} ç¬”äº¤æ˜“ã€‚`, 'ai', 'âœ…');
            } else {
                logMessage(`ç­–ç•¥ 6 (è¶‹åŠ¿è¿½è¸ªè€…): æœ¬è½®æœªæ‰§è¡Œä»»ä½•äº¤æ˜“ã€‚`, 'ai', 'â„¹ï¸', false);
            }
            updateUI();
        }

        // --- Strategy 7: ä»·å€¼å›å½’è€… (Mean Reversion) ---
        function strategy7Logic() {
            let actionsTaken = 0;

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const sma = calculateSMA(stock.name, MEAN_REVERSION_SMA_PERIOD);
                if (sma === null) return; // Not enough data for SMA

                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Priority: Stop Loss, Profit Take, then Reversion Sell)
                if (stock.sharesOwned > 0) {
                    // Stop Loss
                    if (assumedBuyPrice && ((assumedBuyPrice - currentPrice) / assumedBuyPrice) * 100 >= MEAN_REVERSION_STOP_LOSS_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 7 (ä»·å€¼å›å½’è€…): æ­¢æŸå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (äºæŸ: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸ”´', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= MEAN_REVERSION_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 7 (ä»·å€¼å›å½’è€…): æ­¢ç›ˆå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (åˆ©æ¶¦: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸŸ¢', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Mean Reversion Sell (price significantly above SMA)
                    if (currentPrice > sma * (1 + MEAN_REVERSION_SELL_ABOVE_SMA_PERCENT / 100)) {
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned / 2)); // Sell half or default
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 7 (ä»·å€¼å›å½’è€…): ä»·æ ¼åç¦»é«˜ç‚¹å–å‡º ${quantityToSell} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (é«˜äºSMA)`, 'ai', 'ğŸ“‰', false);
                        }
                    }
                }

                // Buy Logic (Mean Reversion - price significantly below SMA)
                if (cash > currentPrice * MIN_PRICE && stock.sharesOwned < MEAN_REVERSION_TRADE_QUANTITY * 5) { // Only buy if enough cash and not too much held
                    if (currentPrice < sma * (1 - MEAN_REVERSION_BUY_BELOW_SMA_PERCENT / 100)) {
                        const quantityToBuy = MEAN_REVERSION_TRADE_QUANTITY;
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 7 (ä»·å€¼å›å½’è€…): ä»·æ ¼åç¦»ä½ç‚¹ä¹°å…¥ ${quantityToBuy} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (ä½äºSMA)`, 'ai', 'ğŸ“ˆ', false);
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`ç­–ç•¥ 7 (ä»·å€¼å›å½’è€…): æœ¬è½®å®Œæˆ ${actionsTaken} ç¬”äº¤æ˜“ã€‚`, 'ai', 'âœ…');
            } else {
                logMessage(`ç­–ç•¥ 7 (ä»·å€¼å›å½’è€…): æœ¬è½®æœªæ‰§è¡Œä»»ä½•äº¤æ˜“ã€‚`, 'ai', 'â„¹ï¸', false);
            }
            updateUI();
        }

        // --- Strategy 8: è¶‹åŠ¿è¿½è¸ªä¼˜åŒ– (Trend Tracking Optimization) ---
        function strategy8Logic() {
            let actionsTaken = 0;
            logMessage(`ç­–ç•¥ 8 (è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–): æ­£åœ¨æ‰§è¡Œæœ¬è½®é€»è¾‘... (å¤©æ•°: ${currentDay})`, 'ai', 'ğŸ”', false); // Always log when logic runs

            stocks.forEach((stock, index) => {
                const currentPrice = stock.price;
                const sma = calculateSMA(stock.name, TREND_TRACKING_OPTIMIZED_SMA_PERIOD);
                if (sma === null) return; // Not enough data for SMA

                const assumedBuyPrice = aiBoughtPrices[stock.name];

                // Sell Logic (Priority: Stop Loss, Profit Take, then Trend Reversal)
                if (stock.sharesOwned > 0) {
                    // Stop Loss
                    if (assumedBuyPrice && ((assumedBuyPrice - currentPrice) / assumedBuyPrice) * 100 >= TREND_TRACKING_OPTIMIZED_STOP_LOSS_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 8 (è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–): æ­¢æŸå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (äºæŸ: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸ”´', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Profit Take
                    if (assumedBuyPrice && ((currentPrice - assumedBuyPrice) / assumedBuyPrice) * 100 >= TREND_TRACKING_OPTIMIZED_PROFIT_TAKE_PERCENT) {
                        if (sellStock(index, stock.sharesOwned, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 8 (è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–): æ­¢ç›ˆå–å‡º ${stock.sharesOwned} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (åˆ©æ¶¦: ${((currentPrice - assumedBuyPrice) / assumedBuyPrice * 100).toFixed(2)}%)`, 'ai', 'ğŸŸ¢', false);
                        }
                        return; // Done with this stock for selling
                    }

                    // Trend Reversal Sell
                    if (currentPrice < sma * (1 - TREND_TRACKING_OPTIMIZED_SELL_BELOW_SMA_PERCENT / 100)) {
                        const quantityToSell = Math.max(DEFAULT_TRADE_QUANTITY, Math.floor(stock.sharesOwned / 2)); // Sell half or default
                        if (sellStock(index, quantityToSell, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 8 (è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–): è¶‹åŠ¿åè½¬å–å‡º ${quantityToSell} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (ä½äºSMA)`, 'ai', 'ğŸ“‰', false);
                        }
                    }
                }

                // Buy Logic (Trend Following)
                if (stock.sharesOwned === 0 && cash > currentPrice * MIN_PRICE) { // Only buy if not held and enough cash
                    if (currentPrice > sma * (1 + TREND_TRACKING_OPTIMIZED_BUY_ABOVE_SMA_PERCENT / 100)) {
                        const quantityToBuy = TREND_TRACKING_OPTIMIZED_TRADE_QUANTITY;
                        if (buyStock(index, quantityToBuy, true, false)) {
                            actionsTaken++;
                            logMessage(`ç­–ç•¥ 8 (è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–): è¶‹åŠ¿ç¡®è®¤ä¹°å…¥ ${quantityToBuy} è‚¡ ${stock.name} @ ${formatCurrency(currentPrice)} (é«˜äºSMA)`, 'ai', 'ğŸ“ˆ', false);
                        }
                    }
                }
            });

            if (actionsTaken > 0) {
                logMessage(`ç­–ç•¥ 8 (è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–): æœ¬è½®å®Œæˆ ${actionsTaken} ç¬”äº¤æ˜“ã€‚`, 'ai', 'âœ…');
            } else {
                logMessage(`ç­–ç•¥ 8 (è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–): æœ¬è½®æœªæ‰§è¡Œä»»ä½•äº¤æ˜“ã€‚`, 'ai', 'â„¹ï¸', false);
            }
            updateUI();
        }

        // --- Initial Call ---
        document.addEventListener('DOMContentLoaded', initializeGame);

        nextDayButton.addEventListener('click', nextDay); // Re-adding the missing event listener

        playAgainButton.addEventListener('click', () => {
            gameOverScreen.style.display = 'none';
            initializeGame();
        });

        // Add listeners for each strategy button
        strategy1Button.addEventListener('click', () => runAiSimulation(strategy1Logic, 'ç­–ç•¥ 1 (æ¶¨è·Œå¹…è¿½å‡»è€…)'));
        strategy2Button.addEventListener('click', () => runAiSimulation(strategy2Logic, 'ç­–ç•¥ 2 (ä»·å€¼æŠ•èµ„è€…)'));
        strategy3Button.addEventListener('click', () => runAiSimulation(strategy3Logic, 'ç­–ç•¥ 3 (äº‹ä»¶å“åº”è€…)'));
        strategy4Button.addEventListener('click', () => runAiSimulation(strategy4Logic, 'ç­–ç•¥ 4 (å°æ­¥å¿«è·‘è€…)'));
        strategy5Button.addEventListener('click', () => runAiSimulation(strategy5Logic, 'ç­–ç•¥ 5 (å¤šå…ƒåŒ–æŠ•èµ„è€…)'));

        // Add listeners for each strategy button
        strategy6Button.addEventListener('click', () => runAiSimulation(strategy6Logic, 'ç­–ç•¥ 6 (è¶‹åŠ¿è¿½è¸ªè€…)'));
        strategy7Button.addEventListener('click', () => runAiSimulation(strategy7Logic, 'ç­–ç•¥ 7 (ä»·å€¼å›å½’è€…)'));
        strategy8Button.addEventListener('click', () => runAiSimulation(strategy8Logic, 'ç­–ç•¥ 8 (è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–)'));

        // Add listeners for bulk action buttons
        buyAllStocksButton.addEventListener('click', buyAllStocks);
        sellAllButton.addEventListener('click', sellAllStocks);
        sellHalfButton.addEventListener('click', sellHalfStocks);
        sellQuarterButton.addEventListener('click', sellQuarterStocks);

        // --- Manual Bulk Buy Function ---
        function buyAllStocks() {
             if (!gameRunning) return;

             logMessage("å°è¯•ä¸ºæ‰€æœ‰è‚¡ç¥¨é›¨éœ²å‡æ²¾...", 'info', 'ğŸ›’');
             let stocksBoughtCount = 0;

             stocks.forEach((stock, index) => {
                 const quantityToBuy = 100; // Fixed quantity
                 // Check if we can afford at least this quantity
                 if (cash >= stock.price * quantityToBuy) {
                      // Use buyStock function, but mark as manual (isAI = false)
                      if (buyStock(index, quantityToBuy, false, false)) {
                           stocksBoughtCount++;
                      }
                 }
             });

             if (stocksBoughtCount > 0) {
                 logMessage(`æˆåŠŸä¸º ${stocksBoughtCount} åªè‚¡ç¥¨ä¹°å…¥ 100 è‚¡ã€‚`, 'success', 'âœ…');
             } else {
                 logMessage("æœªèƒ½ä¸ºä»»ä½•è‚¡ç¥¨ä¹°å…¥ 100 è‚¡ (å¯èƒ½ç°é‡‘ä¸è¶³)ã€‚", 'warn', 'âš ï¸');
             }
             updateUI(); // Update UI after attempting buys
        }

        // --- Custom Stock Addition Function ---
        function addCustomStock() {
            if (!gameRunning) {
                logMessage("æ¸¸æˆæœªå¼€å§‹ï¼Œæ— æ³•æ·»åŠ è‚¡ç¥¨ã€‚", 'warn', 'âš ï¸');
                return;
            }
            const newStockName = newStockNameInput.value.trim();
            const newStockCode = newStockCodeInput.value.trim();
            const newStockPrice = parseFloat(newStockPriceInput.value);

            if (!newStockName || !newStockCode || isNaN(newStockPrice) || newStockPrice <= 0) {
                logMessage("è¯·è¾“å…¥æœ‰æ•ˆçš„è‚¡ç¥¨åç§°ã€ä»£ç å’Œåˆå§‹ä»·æ ¼ã€‚", 'error', 'âŒ');
                return;
            }

            // Check for duplicate name
            if (stocks.some(s => s.name === newStockName)) {
                logMessage(`è‚¡ç¥¨ '${newStockName}' å·²å­˜åœ¨ï¼Œè¯·ä½¿ç”¨å…¶ä»–åç§°ã€‚`, 'error', 'âŒ');
                return;
            }

            const newStock = {
                name: newStockName,
                code: newStockCode,
                price: newStockPrice,
                sharesOwned: 0,
                basePrice: newStockPrice,
                growthFactor: (Math.random() * (BASE_PRICE_GROWTH_RATE_MAX - BASE_PRICE_GROWTH_RATE_MIN) + BASE_PRICE_GROWTH_RATE_MIN) / 365,
                previousDayChangePercent: 0
            };

            stocks.push(newStock);
            stocks.sort((a, b) => a.name.localeCompare(b.name)); // Re-sort stocks alphabetically
            historicalPrices[newStock.name] = [newStock.price]; // Initialize historical prices
            previousPrices[newStock.name] = newStock.price; // Initialize previous price for new stock

            logMessage(`æˆåŠŸæ·»åŠ è‚¡ç¥¨: ${newStockName}ï¼Œä»£ç : ${newStockCode}ï¼Œåˆå§‹ä»·æ ¼: ${formatCurrency(newStockPrice)}`, 'success', 'â•');
            newStockNameInput.value = ''; // Clear input fields
            newStockCodeInput.value = '';
            newStockPriceInput.value = '';
            updateUI(); // Re-render table with new stock

            // --- Save updated stocks to localStorage ---
            saveCustomStocks();
        }

        // New: Function to save custom stocks to localStorage
        function saveCustomStocks() {
            // Only save the essential properties needed to recreate the stock list
            const stocksToSave = stocks.map(stock => ({
                name: stock.name,
                code: stock.code,
                price: stock.price // Save the current price as the re-initialization price
            }));
            localStorage.setItem('customStocks', JSON.stringify(stocksToSave));
            logMessage("è‚¡ç¥¨åˆ—è¡¨å·²è‡ªåŠ¨ä¿å­˜ã€‚", 'info', 'ğŸ’¾', true); // Suppress frequent logging
        }

        // New: Function to clear saved custom stocks from localStorage
        function clearSavedCustomStocks() {
            localStorage.removeItem('customStocks');
            logMessage("å·²æ¸…é™¤æ‰€æœ‰å·²ä¿å­˜çš„è‡ªå®šä¹‰è‚¡ç¥¨ã€‚", 'info', 'ğŸ—‘ï¸');
            // After clearing, re-initialize the game to reflect the change
            initializeGame();
        }

        // --- Help Modal Logic ---
        function populateStrategyExplanations() {
            const strategies = [
                { id: 'strategy1Button', name: 'ç­–ç•¥ 1: æ¶¨è·Œå¹…è¿½å‡»è€…', description: 'æ ¹æ®è‚¡ç¥¨æ¯æ—¥ä»·æ ¼çš„æ˜¾è‘—è·Œå¹…ä¹°å…¥ï¼Œåœ¨æ˜¾è‘—æ¶¨å¹…ã€è¾¾åˆ°æ­¢ç›ˆç‚¹æˆ–è§¦åŠæ­¢æŸçº¿æ—¶å–å‡ºã€‚è¿½æ±‚çŸ­æœŸæ³¢åŠ¨æ”¶ç›Šã€‚å‚æ•°ï¼šä¹°å…¥è·Œå¹…â‰¥3%ï¼Œå–å‡ºæ¶¨å¹…â‰¥2%ï¼Œæ­¢ç›ˆâ‰¥7%ï¼Œæ­¢æŸâ‰¥3%ã€‚'},
                { id: 'strategy2Button', name: 'ç­–ç•¥ 2: ä»·å€¼æŠ•èµ„è€…', description: 'å¯»æ‰¾ä»·æ ¼ä½äºå¹³å‡æ°´å¹³æˆ–ç»å¯¹å€¼è¾ƒä½çš„"ä¾¿å®œè‚¡"ï¼Œé•¿æœŸæŒæœ‰ã€‚åœ¨ä»·æ ¼å¤§å¹…ä¸Šæ¶¨å¹¶è¾¾åˆ°æ­¢ç›ˆç‚¹æ—¶å–å‡ºã€‚æ³¨é‡é•¿æœŸä»·å€¼æŠ•èµ„ã€‚å‚æ•°ï¼šä½äº50å…ƒæˆ–å¹³å‡ä»·æ ¼çš„80%ä¹°å…¥ï¼Œæ­¢ç›ˆâ‰¥25%ã€‚'},
                { id: 'strategy3Button', name: 'ç­–ç•¥ 3: äº‹ä»¶å“åº”è€…', description: 'ç§¯æå“åº”å¸‚åœºäº‹ä»¶ï¼šè‹¥è‚¡ç¥¨å—æ­£é¢äº‹ä»¶å½±å“åˆ™ä¹°å…¥ï¼›è‹¥å—è´Ÿé¢äº‹ä»¶å½±å“åˆ™å–å‡ºã€‚åŒæ—¶ï¼Œä¹Ÿä¼šå¯¹å·²æŒæœ‰çš„é«˜åˆ©æ¶¦è‚¡ç¥¨è¿›è¡Œæ­¢ç›ˆã€‚å‚æ•°ï¼šå› æ­£é¢äº‹ä»¶ä¹°å…¥çš„è‚¡ç¥¨ä¸Šæ¶¨8%åæ­¢ç›ˆã€‚'},
                { id: 'strategy4Button', name: 'ç­–ç•¥ 4: å°æ­¥å¿«è·‘è€…', description: 'è¿½æ±‚é¢‘ç¹çš„å°é¢äº¤æ˜“ã€‚åœ¨è‚¡ç¥¨å°å¹…ä¸Šæ¶¨æ—¶å¿«é€Ÿä¹°å…¥ï¼Œå¹¶åœ¨è¾¾åˆ°å¾®è–„åˆ©æ¶¦æˆ–å‡ºç°å°å¹…ä¸‹è·Œæ—¶è¿…é€Ÿå–å‡ºã€‚æ³¨é‡æ—¥å†…äº¤æ˜“å’Œèµ„é‡‘å‘¨è½¬ã€‚å‚æ•°ï¼šä¹°å…¥æ¶¨å¹…0.1%-0.5%ï¼Œæ­¢ç›ˆâ‰¥0.8%ï¼Œå½“æ—¥è·Œå¹…â‰¥0.1%æ­¢æŸã€‚'},
                { id: 'strategy5Button', name: 'ç­–ç•¥ 5: å¤šå…ƒåŒ–æŠ•èµ„è€…', description: 'æ—¨åœ¨æ„å»ºå¹¶ç»´æŒä¸€ä¸ªå¹¿æ³›åˆ†æ•£çš„æŠ•èµ„ç»„åˆã€‚åœ¨æŒè‚¡æ•°é‡ä¸è¶³æˆ–æŸäº›è‚¡ç¥¨æƒé‡è¿‡ä½æ—¶ä¹°å…¥ï¼›åœ¨è‚¡ç¥¨å¸‚å€¼å æ¯”è¿‡é«˜æ—¶å–å‡ºä»¥è¿›è¡Œå†å¹³è¡¡ã€‚å‚æ•°ï¼šç›®æ ‡æŒæœ‰50åªè‚¡ç¥¨ï¼Œå•åªè‚¡ç¥¨å¸‚å€¼ä¸è¶…è¿‡æ€»å¸‚å€¼3%ã€‚'},
                { id: 'strategy6Button', name: 'ç­–ç•¥ 6: è¶‹åŠ¿è¿½è¸ªè€…', description: 'è¯†åˆ«å¹¶è·Ÿéšè‚¡ç¥¨çš„çŸ­æœŸä»·æ ¼è¶‹åŠ¿ã€‚å½“ä»·æ ¼æŒç»­ä¸Šæ¶¨æ—¶ä¹°å…¥ï¼ŒæŒç»­ä¸‹è·Œæ—¶å–å‡ºã€‚å‚æ•°ï¼šåŸºäº5æ—¥SMAï¼Œä»·æ ¼é«˜äºSMA 0.5%ä¹°å…¥ï¼Œä½äºSMA 0.5%å–å‡ºï¼Œæ­¢ç›ˆ10%ï¼Œæ­¢æŸ5%ã€‚'},
                { id: 'strategy7Button', name: 'ç­–ç•¥ 7: ä»·å€¼å›å½’è€…', description: 'åˆ©ç”¨è‚¡ç¥¨ä»·æ ¼å›´ç»•å…¶å†…åœ¨ä»·å€¼æ³¢åŠ¨çš„ç‰¹æ€§ã€‚å½“ä»·æ ¼æ˜¾è‘—ä½äºæˆ–é«˜äºå†…åœ¨ä»·å€¼æ—¶è¿›è¡Œäº¤æ˜“ï¼ŒæœŸå¾…ä»·æ ¼å›å½’ã€‚å‚æ•°ï¼šåŸºäº10æ—¥SMAï¼Œä»·æ ¼ä½äºSMA 5%ä¹°å…¥ï¼Œé«˜äºSMA 5%å–å‡ºï¼Œæ­¢ç›ˆ25%ï¼Œæ­¢æŸ5%ã€‚'},
                { id: 'strategy8Button', name: 'ç­–ç•¥ 8: è¶‹åŠ¿è¿½è¸ªä¼˜åŒ–', description: 'è¯†åˆ«å¹¶è·Ÿéšè‚¡ç¥¨çš„çŸ­æœŸä»·æ ¼è¶‹åŠ¿ã€‚å½“ä»·æ ¼æŒç»­ä¸Šæ¶¨æ—¶ä¹°å…¥ï¼ŒæŒç»­ä¸‹è·Œæ—¶å–å‡ºã€‚å‚æ•°ï¼šåŸºäº5æ—¥SMAï¼Œä»·æ ¼é«˜äºSMA 0.5%ä¹°å…¥ï¼Œä½äºSMA 0.5%å–å‡ºï¼Œæ­¢ç›ˆ15%ï¼Œæ­¢æŸ5%ã€‚'}
            ];

            strategyExplanationContent.innerHTML = ''; // Clear previous content

            strategies.forEach(strategy => {
                const h3 = document.createElement('h3');
                h3.textContent = strategy.name;
                strategyExplanationContent.appendChild(h3);

                const p = document.createElement('p');
                p.textContent = strategy.description;
                strategyExplanationContent.appendChild(p);
            });
        }

        // Event listener for opening the modal
        helpIcon.addEventListener('click', () => {
            populateStrategyExplanations(); // Populate content before showing
            strategyHelpModal.style.display = 'block';
        });

        // Event listener for closing the modal
        closeButton.addEventListener('click', () => {
            strategyHelpModal.style.display = 'none';
        });

        // Close modal if user clicks outside of it
        window.addEventListener('click', (event) => {
            if (event.target == strategyHelpModal) {
                strategyHelpModal.style.display = 'none';
            }
        });

        // Add listener for custom stock addition
        addStockButton.addEventListener('click', addCustomStock);

        // New: Add listener for clear saved stocks button
        const clearSavedStocksButton = document.getElementById('clearSavedStocksButton');
        if (clearSavedStocksButton) {
            clearSavedStocksButton.addEventListener('click', clearSavedCustomStocks);
        }

    </script>

    <!-- Confetti library for winning effect -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
</body>
</html>